{
  ".snow/notebook/": [
    {
      "id": "notebook-1771735997275_zjuil6i5h",
      "filePath": ".snow/notebook/",
      "note": "职责: Snow CLI 项目蓝图与知识库持久化目录(由工具管理).存放文件级与文件夹级 notebook 条目,用于约束架构边界与避坑指南.\n\n使用规范:\n- MUST 仅使用 notebook-* 工具增删改,禁止手动编辑 json.\n- 过程性内容(临时计划,冲突处理过程)应尽量写在 requirements/ 或 CurrentTaskPlan.md,并在完成后清理对应 notebook 条目.\n\n避坑指南:\n- notebook 条目应保持\"长期有效\",避免记录时间敏感的开发日志.\n- 目录级 notebook 用于跨文件约束,文件级 notebook 用于脆弱实现与关键接口契约.",
      "createdAt": "2026-02-22T12:53:17.275",
      "updatedAt": "2026-02-22T12:53:17.275"
    }
  ],
  "docs/usage/zh/20.SSE服务模式.md": [
    {
      "id": "notebook-1771478236512_49avnxm82",
      "filePath": "docs/usage/zh/20.SSE服务模式.md",
      "note": "职责: SSE 服务模式对外协议文档(面向用户/集成方),定义事件类型,客户端消息类型,端点行为,以及错误码语义.\\n接口摘要: \\n- 输入: Snow CLI 的 SSE 服务器实现(source/api/sse-server.ts + source/utils/sse/sseManager.ts).\\n- 输出: 稳定的协议契约,供示例客户端(source/test/sse-client/)与第三方客户端实现.\\n依赖拓扑: \\n- 被依赖: source/test/sse-client/app.js 的事件分发与消息发送,以及 requirements/SSE客户端适配主代理.md 的实现依据.\\n避坑指南: \\n- 文档中的字段名大小写与数据结构必须与服务端实际 sendEvent 输出一致,避免示例客户端与真实协议偏差.\\n- 新增事件类型(如 agent_list,agent_switched)必须明确: 触发时机,幂等性,与 sessionId 绑定规则,避免客户端出现状态机歧义.\\n- 错误码表必须保持向后兼容: 允许服务端新增 errorCode,客户端应对未知 code 做兜底展示.",
      "createdAt": "2026-02-19T13:17:16.512",
      "updatedAt": "2026-02-19T13:17:16.512"
    }
  ],
  "requirements/": [
    {
      "id": "notebook-1771495044343_9q2dkp8qw",
      "filePath": "requirements/",
      "note": "职责: 需求与变更记录目录(SSoT).存放功能需求、协议契约与验收标准,作为实现与回归测试的唯一依据.\n\n接口摘要:\n- 输入: 产品/开发需求.\n- 输出: 可执行的实现约束(协议字段,UI 行为,错误码文案,验收清单),指导:\n  - 正式 Web 客户端子项目(sse-client/)的长期实现.\n  - 浏览器测试客户端(source/test/sse-client/)的协议联调与回归.\n\n依赖拓扑:\n- 被依赖:\n  - sse-client/ 的产品实现与回归测试.\n  - source/test/sse-client/* 的示例实现与联调.\n  - 服务端 SSE 协议演进评审(source/api/sse-server.ts,source/utils/sse/sseManager.ts).\n\n避坑指南:\n- 需求文档必须保持 SSoT: 协议字段/错误码/事件类型变更,必须同步更新对应文档.\n- 标注兼容性要求: unknown event.type 必须静默忽略,避免客户端因协议扩展崩溃.\n- 明确歧义字段: 例如 currentAgentId 可为 null 的语义,以及 Git 视图隐藏区域的口径必须全篇一致.",
      "createdAt": "2026-02-19T17:57:24.343",
      "updatedAt": "2026-02-19T23:40:49.131"
    }
  ],
  "requirements/API渠道冲突合并需求文档.md": [
    {
      "id": "notebook-1771735983400_at2zw7mca",
      "filePath": "requirements/API渠道冲突合并需求文档.md",
      "note": "职责: 模型渠道适配(source/api/*)合并冲突的需求与验收口径(过程性+规范性混合).该文档是本轮合并的 SSoT,用于定义必须吸收/必须保留的能力与统一行为.\n\n依赖拓扑:\n- 被依赖: source/api/ 模块级 notebook,以及四个适配器文件级 notebook(anthropic/chat/gemini/responses).\n\n避坑指南:\n- 文档中的\"统一规范\"应最终沉淀到 source/api/ 的长期 notebook 中,避免后续开发仅靠该需求文档口口相传.\n- 若未来再次发生渠道合并冲突,应先更新本文件的验收口径,再改代码,最后同步更新 notebook.",
      "createdAt": "2026-02-22T12:53:03.400",
      "updatedAt": "2026-02-22T12:53:03.400"
    }
  ],
  "requirements/SSE客户端适配主代理.md": [
    {
      "id": "notebook-1771494873344_kvcdeq9mx",
      "filePath": "requirements/SSE客户端适配主代理.md",
      "note": "职责: SSE 客户端示例适配主代理的需求与协议约束的单一事实源.用于定义 agent_list,agent_switched,switch_agent 的数据结构,以及客户端 UI 交互规则与错误码提示策略.\n\n接口摘要:\n- 输入: 服务端协议能力(见 source/api/sse-server.ts,source/utils/sse/sseManager.ts).\n- 输出: 客户端实现准则(source/test/sse-client/ 下的 index.html,style.css,app.js),以及后续迭代的验收标准.\n\n依赖拓扑:\n- 被依赖: source/test/sse-client/app.js(事件处理与状态机),UI 文件(index.html/style.css).\n\n避坑指南:\n- currentAgentId 可为 null: 表示连接未绑定会话或服务端未确认当前代理,客户端 UI 必须能处理并进入预选或占位状态.\n- 错误消息语言策略: error.message 可能为英文或开发者向信息,客户端应优先用 errorCode 映射用户友好中文文案,仅在未知 errorCode 时回退展示 message.\n- 协议扩展需向后兼容: 客户端对未知 event.type 静默忽略,服务端新增事件不要复用旧类型语义.",
      "createdAt": "2026-02-19T17:54:33.344",
      "updatedAt": "2026-02-19T17:54:33.344"
    }
  ],
  "requirements/全平台网页版Snow SSE客户端需求.md": [
    {
      "id": "notebook-1771515649312_x6aph0c29",
      "filePath": "requirements/全平台网页版Snow SSE客户端需求.md",
      "note": "职责: 正式 Web SSE 客户端(sse-client/)的唯一需求基线(SSoT).定义信息架构,UI 布局规则,本地控制 API 契约,以及验收标准.\n\n接口摘要:\n- 输入: 用户目标与现有 SSE 服务端能力边界.\n- 输出:\n  - Web 客户端必须实现的页面结构(聊天视图 vs Git 视图平级切换),弹窗交互(审批/提问),以及 Git 基础能力.\n  - 本地控制 API 的最小端点集合(/api/servers...).\n\n验收口径更新(必须遵守,以 2.5 为准):\n- 服务端选择下拉框(serverSelect)已移除,服务切换仅通过顶部服务端 Tab.\n- 连接控制区移除\"连接 SSE\"按钮(connectBtn),统一为单一\"重连\"按钮(reconnectBtn).\n- 每个服务端 Tab 下连接控制固定为两个按钮:\"重连\"+\"关闭\"(closeServerBtn 关闭当前服务端).\n- \"停止全部\"属于服务管理区,不属于每个 Tab 的连接控制区(避免验收歧义).\n\n依赖拓扑:\n- 被依赖: sse-client/ 子项目的 UI/状态/控制 API 设计与实现.\n- 参考: docs/usage/zh/20.SSE服务模式.md(服务端协议),requirements/SSE客户端适配主代理.md(主代理事件/错误码).\n\n避坑指南:\n- 本文档为最终口径,与任何旧描述冲突时以本文档为准.\n- Git 视图隐藏范围,日志弹窗仅事件流,TODO 常驻等规则必须在实现中严格对齐.\n- 认证口径为 Web 入口门禁,不是要求改造 Snow SSE 各业务端点逐请求鉴权.",
      "createdAt": "2026-02-19T23:40:49.312",
      "updatedAt": "2026-02-21T20:17:37.305"
    }
  ],
  "requirements/合并到0.6.32冲突解决需求文档.md": [
    {
      "id": "notebook-1771735973924_t53il5lc3",
      "filePath": "requirements/合并到0.6.32冲突解决需求文档.md",
      "note": "职责: 合并上游 0.6.32 时的冲突解决过程记录(过程性).用于回溯当时的取舍,不应作为长期架构规范.\n\n使用建议:\n- 若对应冲突已完全解决且代码已稳定,可考虑在后续整理时删除或仅保留关键架构结论到长期笔记(如 source/api/ 统一规范).\n\n避坑指南:\n- 不要在该文档中新增新需求或架构决策,新的架构约束应写入对应模块 notebook(如 source/api/ 或 source/utils/).",
      "createdAt": "2026-02-22T12:52:53.924",
      "updatedAt": "2026-02-22T12:52:53.924"
    }
  ],
  "requirements/合并到0.6.33冲突解决需求文档.md": [
    {
      "id": "notebook-1771735974038_b0q52xqaa",
      "filePath": "requirements/合并到0.6.33冲突解决需求文档.md",
      "note": "职责: 合并上游 0.6.33 时的冲突解决过程记录(过程性).用于回溯当时的取舍,不应作为长期架构规范.\n\n使用建议:\n- 冲突解决完成后,应把长期有效的结论沉淀到模块级 notebook,并避免未来迭代继续引用该过程文档作为规范.\n\n避坑指南:\n- 禁止把该过程文档当作 SSoT,SSoT 应是 requirements/具体需求文档 + 模块级 notebook 约束.",
      "createdAt": "2026-02-22T12:52:54.038",
      "updatedAt": "2026-02-22T12:52:54.038"
    }
  ],
  "source/": [
    {
      "id": "notebook-1771735800416_uz5vjb17k",
      "filePath": "source/",
      "note": "职责: Snow CLI(TUI)核心源码根目录.承载 CLI 入口、TUI 界面、对话执行、代理系统、模型渠道适配、MCP 集成、配置与工具体系.\n\n模块边界(长期规范):\n- source/ 只包含 Snow CLI 主程序相关代码,不包含独立子项目(sse-client/).\n- UI(ink/react)与核心逻辑必须分层: UI 只做状态展示与交互编排,对话执行/模型调用/工具系统在 utils/api/mcp/prompt 等模块.\n\n依赖拓扑:\n- 入口: source/cli.tsx,source/app.tsx.\n- 关键子模块:\n  - source/utils/: 对话执行、会话、代理运行时、SSE 管理、通用工具.\n  - source/api/: 模型渠道适配器(Anthropic/OpenAI Chat/OpenAI Responses/Gemini).\n  - source/mcp/: MCP 客户端与工具管理.\n  - source/config/: 内置配置(默认主代理,内置 mainAgents 等).\n  - source/prompt/: 系统提示词与提示词模块(shared 等).\n  - source/ui/: Ink 组件与屏幕(screen)体系.\n\n避坑指南:\n- 不在 UI 层直接调用模型适配器或拼接提示词,统一经由 utils 层的执行器/manager.\n- 新增跨模块能力必须补齐对应 notebook 条目(职责,接口摘要,依赖拓扑,避坑).",
      "createdAt": "2026-02-22T12:50:00.416",
      "updatedAt": "2026-02-22T12:50:00.416"
    }
  ],
  "source/agents/": [
    {
      "id": "notebook-1771735800549_nrmgzgnnt",
      "filePath": "source/agents/",
      "note": "职责: 内置子代理实现集合.这些 agent 以代码形式提供固定能力(如 review/summary/compact/codebase-*),由主代理系统根据配置或命令触发.\n\n接口摘要:\n- 输入: 会话上下文 + 工具系统 + 角色定义提示词(由主代理系统注入).\n- 输出: agent 的文本回复,或通过工具调用产生的副作用.\n\n依赖拓扑:\n- 依赖: prompt 系统(系统提示词),utils 执行器,tools 注册.\n- 被依赖: 主代理运行时(MainAgentManager/执行层)用于 spawn/切换子代理.\n\n避坑指南:\n- 子代理不应直接读写 UI 状态,只通过标准工具接口与主代理通信.\n- 子代理能力变更必须同步 toml 配置与权限(限制可编辑文件类型等),避免运行时越权或能力缺失.",
      "createdAt": "2026-02-22T12:50:00.549",
      "updatedAt": "2026-02-22T12:50:00.549"
    }
  ],
  "source/api/": [
    {
      "id": "notebook-1771495044055_cbcvm3sjp",
      "filePath": "source/api/",
      "note": "职责: 模型渠道适配层.承载各第三方模型渠道适配器(source/api/*.ts),负责把内部统一的 ChatMessage/ToolCall 结构映射为各渠道请求格式,并解析渠道流式响应(SSE/HTTP stream).\n\n不该做什么:\n- 不承载会话业务状态,不维护 UI 状态.\n- 不做主代理/子代理选择逻辑与会话级状态管理(归 MainAgentManager + execution/session).\n\n统一架构原则(长期规范,跨 4 适配器一致,SSoT: requirements/API渠道冲突合并需求文档.md):\n1) 多条自定义 system prompt 支持:\n- customSystemPromptOverride 类型统一为 string[] | undefined,顺序敏感.\n- 各渠道可用等价映射表达(多条 system 消息或拼接为单条),但语义与顺序必须一致.\n\n2) system prompt 优先级模型(4 文件完全一致):\n1) 子代理调用且配置多条自定义 system prompts -> 使用子代理自定义数组.\n2) 子代理调用且无自定义但有子代理角色定义 -> 使用子代理角色定义.\n3) 主代理调用且配置多条自定义 system prompts -> 使用主代理自定义数组.\n4) 无自定义且允许内置 -> 使用对应代理的角色定义.\n\n3) 主/子代理提示词隔离(硬约束):\n- 角色定义提示词仅来自当前调用所属 agent profile,不得跨注入.\n- customSystemPromptOverride 仅影响本次调用,不得写回 profile.\n\n4) 特殊 user 消息后插语义:\n- 必须保留动态后插能力,且插入位置策略不得随 system prompt 来源变化.\n\n5) 多模态兼容与中转平台支持:\n- 必须保留本地对 Responses API 的多模态特殊处理(尤其是工具返回与图片消息拆分策略).\n- 合并 upstream 能力时,以\"能力并存\"为准则,禁止覆盖删除本地兼容路径.\n\n6) 流式健壮性(保护模式,所有适配器一致):\n- 必须接入 idle timeout guard(180000ms) + abandoned 丢弃.\n- abort 时必须 abandon 并 return,避免延迟 chunk 外泄.\n- done=true 但 buffer.trim() 非空必须抛可重试错误.\n\n依赖拓扑:\n- 依赖: source/utils/core/*(streamGuards,retryUtils 等),source/prompt/*(提示词组装),source/types/*.\n- 被依赖: source/utils/execution/* 与会话执行层.\n\n避坑指南:\n- 禁止单文件漂移: 任一适配器新增字段映射或 system prompt 处理规则,必须同步到其他 3 个适配器或明确标注差异原因.\n- 解冲突时优先保留本地多模态链路与主/子代理隔离边界,再吸收 upstream 的多 system prompts 能力.",
      "createdAt": "2026-02-19T17:57:24.055",
      "updatedAt": "2026-02-22T12:51:53.936"
    }
  ],
  "source/api/anthropic.ts": [
    {
      "id": "notebook-1770694883398_3ow0urpes",
      "filePath": "source/api/anthropic.ts",
      "note": "职责: Anthropic API 适配器.将内部 ChatMessage 转换为 Anthropic 消息格式,并实现 Anthropic 流式 SSE 解析与产出.\n\n接口摘要:\n- createStreamingAnthropicCompletion(options,abortSignal,onRetry) -> AsyncGenerator<AnthropicStreamChunk>.\n- parseSSEStream(reader,abortSignal?) 解析 SSE data 行 JSON 并 yield.\n\n架构规范(必须与 chat/gemini/responses 对齐):\n- customSystemPromptOverride: 支持多条自定义 system prompts(string[]),顺序敏感.\n- system prompt 优先级: 遵循 source/api/ 统一 1-4 模型.\n- 主/子代理隔离: 角色定义提示词仅来自当前调用 agent profile.\n- 特殊 user 消息后插: 保留动态后插语义.\n\n流式保护模式(不得破坏):\n- idle timeout guard(180000ms) + abandoned 丢弃.\n- abort 时 abandon 并 return.\n- done=true 但 buffer.trim() 非空必须抛可重试错误.\n\n避坑指南:\n- 不要把 system prompts 在此文件中退化为单字符串,否则会与其他适配器产生语义漂移.\n- 解冲突时,先对齐统一提示词模型,再做渠道特有字段映射.",
      "createdAt": "2026-02-10T11:41:23.398",
      "updatedAt": "2026-02-22T12:51:54.085"
    }
  ],
  "source/api/chat.ts": [
    {
      "id": "notebook-1770694883572_4ydxyl8k0",
      "filePath": "source/api/chat.ts",
      "note": "职责: OpenAI ChatCompletions API 适配器.负责消息格式转换与 ChatCompletions 流式 SSE 解析.\n\n接口摘要:\n- createStreamingChatCompletion(options,abortSignal,onRetry) -> AsyncGenerator<ChatCompletionChunk|...>.\n- parseSSEStream(reader,abortSignal?) 解析 SSE data 行 JSON 并 yield.\n\n统一规范(必须与 anthropic/gemini/responses 对齐):\n- customSystemPromptOverride: 多条 system prompts(string[]),顺序敏感.\n- system prompt 优先级: 遵循 source/api/ 统一 1-4 模型.\n- 主/子代理隔离: 角色定义提示词仅来自当前调用 agent profile.\n- 特殊 user 消息后插: 必须保留且位置策略一致.\n\n流式保护模式(不得破坏):\n- idle timeout guard(180000ms) + abandoned 丢弃 + finally dispose.\n- abort 时 abandon.\n- done=true 且 buffer.trim() 非空必须抛可重试错误.\n\n避坑指南:\n- 禁止把多 system prompts 在此文件拼接成单字符串,而其他适配器保持多条消息,会导致行为不一致.\n- 不要将 UI/会话状态写入该层.",
      "createdAt": "2026-02-10T11:41:23.572",
      "updatedAt": "2026-02-22T12:51:54.218"
    }
  ],
  "source/api/gemini.ts": [
    {
      "id": "notebook-1770694883908_ow13cu46t",
      "filePath": "source/api/gemini.ts",
      "note": "职责: Google Gemini API 适配器.将内部 ChatMessage 转换为 Gemini 请求格式,并实现 Gemini 流式读取与产出.\n\n接口摘要:\n- createStreamingGeminiCompletion(options,abortSignal,onRetry) -> AsyncGenerator<GeminiStreamChunk>.\n\n统一规范(必须与 anthropic/chat/responses 对齐):\n- customSystemPromptOverride: 多条 system prompts(string[]),顺序敏感.\n- system prompt 优先级: 遵循 source/api/ 统一 1-4 模型.\n- 主/子代理隔离: 角色定义提示词仅来自当前调用 agent profile.\n- 特殊 user 消息后插: 保留动态后插语义.\n\n流式保护模式(不得破坏):\n- idle timeout guard(180000ms),abort abandon,done 残留半包抛错,finally dispose.\n\n避坑指南:\n- Gemini 的 message/parts 映射容易把 system prompt 与普通文本混淆,必须确保系统提示词路径与用户消息路径严格区分.\n- 若渠道限制需要合并多条 system prompt,必须显式保留顺序语义.",
      "createdAt": "2026-02-10T11:41:23.908",
      "updatedAt": "2026-02-22T12:51:54.334"
    }
  ],
  "source/api/responses.ts": [
    {
      "id": "notebook-1770694883742_l9t553m1w",
      "filePath": "source/api/responses.ts",
      "note": "职责: OpenAI Responses API 适配器.将内部 ChatMessage 转换为 Responses API 请求格式,并实现 Responses 流式 SSE 解析.\n\n接口摘要:\n- createStreamingResponse(options,abortSignal,onRetry) -> AsyncGenerator<ResponseStreamChunk>.\n\n统一规范(必须与 anthropic/chat/gemini 对齐):\n- customSystemPromptOverride: 多条 system prompts(string[]),顺序敏感.\n- system prompt 优先级: 遵循 source/api/ 统一 1-4 模型.\n- 主/子代理隔离: 角色定义提示词仅来自当前调用 agent profile.\n- 特殊 user 消息后插: 必须保留.\n\nResponses 渠道映射约束:\n- 多条 system prompts 可能映射到 system 或 instruction 等字段,但必须保持与其他渠道等价语义与顺序.\n\n本地不可覆盖点(中转平台兼容):\n- 必须保留本地 Responses 多模态特殊处理路径,尤其是图片消息拆分与 tool_result 兼容策略.\n- 解冲突时以保留本地多模态链路为先,再吸收 upstream 的多 system prompts 能力,禁止反向覆盖.\n\n流式保护模式(不得破坏):\n- parseSSEStream 内 abort abandon,guard.touch/isAbandoned,timeout error throw,finally dispose.\n\n避坑指南:\n- 本文件最容易在解冲突时被 upstream 覆盖掉本地多模态处理,每次合并必须显式比对保留.\n- 注意多模态与系统提示词注入的相对顺序,避免改变上下文语义.",
      "createdAt": "2026-02-10T11:41:23.741",
      "updatedAt": "2026-02-22T12:51:54.449"
    }
  ],
  "source/api/sse-server.ts": [
    {
      "id": "notebook-1770979050662_42h7p1qh5",
      "filePath": "source/api/sse-server.ts",
      "note": "职责: SSE 协议层与连接管理(HTTP EventSource).负责维护 SSEEventType/ClientMessage/AgentInfo 等协议类型,建立与关闭 SSE 连接,并维护 connectionId <-> sessionId 的单对单绑定.通过回调把协议事件交给业务层(SSEManager),自身不持久化会话业务状态.\n\n新增/关键机制(sessionBoundHandler):\n- 提供 setSessionBoundHandler(handler),用于在 /session/create 与 /session/load 完成 bindSessionToConnection(sessionId, connectionId) 后,向业务层同步连接已绑定会话的事实.\n- handler 签名: (sessionId: string, connectionId: string) => void.\n\n接口摘要:\n- 输入: ClientMessage(由 /message 接口或其他 API 转发),以及 /events SSE 长连接.\n- 输出: SSEEvent 流(connected,message,agent_list,agent_switched,error 等),以及 session API 的 JSON 响应.\n\n依赖拓扑:\n- 上游: 无(HTTP 入口).\n- 下游: source/utils/sse/sseManager.ts(业务 messageHandler),source/utils/session/sessionManager.ts(会话创建/加载).\n\n避坑指南:\n- 职责边界: 本层只做协议与连接生命周期管理,不要在这里做主代理选择/切换逻辑,避免与 SSEManager/sessionManager 职责重叠.\n- 回调时序: sessionBoundHandler 必须在 bindSessionToConnection 成功后触发,否则业务层会出现 session_not_found 误判.\n- 防重复绑定: sessionBoundHandler 内部不得反向调用 SSEServer.bindSessionToConnection,避免循环或覆盖绑定.业务层只应更新自己的 mirror 映射.\n- 兼容性: 新增事件类型(agent_list/agent_switched)必须向后兼容,老客户端需忽略未知 event.type.",
      "createdAt": "2026-02-13T18:37:30.662",
      "updatedAt": "2026-02-19T17:54:32.905"
    }
  ],
  "source/config/mainAgents/": [
    {
      "id": "notebook-1771735800708_5a84pzbvn",
      "filePath": "source/config/mainAgents/",
      "note": "职责: 内置主代理配置集合(SSoT for built-in).提供每个内置主代理的默认 profile(名称,描述,系统提示词/角色定义,工具权限,限制可编辑文件类型等).\n\n接口摘要:\n- 输入: 无(静态内置配置).\n- 输出: 供 MainAgentManager 合并到运行时配置树的 BuiltinMainAgentConfig 列表/映射.\n\n依赖拓扑:\n- 被依赖: source/utils/MainAgentManager.ts 初始化阶段加载,并与用户自定义 main-agents.toml 合并.\n\n避坑指南:\n- 内置 id 必须稳定,且与 BUILTIN_AGENT_ORDER 对齐,否则 TUI 与 SSE 的 agent_list 顺序会漂移.\n- 修改内置代理的工具权限或可编辑文件类型限制时,必须同步更新文档/笔记中的隔离边界,避免主/子代理越权.",
      "createdAt": "2026-02-22T12:50:00.708",
      "updatedAt": "2026-02-22T12:50:00.708"
    }
  ],
  "source/hooks/ui/usePanelState.ts": [
    {
      "id": "notebook-1770950000003_usepanelstate",
      "filePath": "source/hooks/ui/usePanelState.ts",
      "note": "职责: UI 面板状态管理 hook,负责维护当前展示的 Panel 类型与来源等状态.\n接口摘要:\n- usePanelState() 提供 show/hide/toggle 等对面板状态的操作.\n依赖拓扑:\n- 上游: 各 TUI screen/组件.\n- 下游: 内部状态容器.\n避坑指南:\n- 本 hook 不应依赖 API 适配器或网络层逻辑,保持 UI 与 core/network 解耦.\n备注:\n- 与\"流式 API idle timeout/断开后丢弃\"无关.相关逻辑应由 api adapters + utils/core(streamGuards,retryUtils)处理,且属于固定 3 分钟不可配置的健壮性机制.不要把 hasYielded,timeoutMs 等网络状态塞进 UI 面板状态.",
      "createdAt": "2026-02-13T09:40:00.000",
      "updatedAt": "2026-02-13T11:52:16.686"
    }
  ],
  "source/mcp/": [
    {
      "id": "notebook-1771735860039_agt0warvn",
      "filePath": "source/mcp/",
      "note": "职责: MCP(Model Context Protocol)集成层.负责连接 MCP server,发现/注册工具,并将 MCP 工具以统一接口暴露给对话执行层.\n\n接口摘要:\n- 输入: MCP 配置(全局/项目),会话上下文,工具调用请求.\n- 输出: Tool 列表,tool execution 结果,以及工具可用性状态.\n\n依赖拓扑:\n- 依赖: source/utils/config/ 读取与编辑配置,source/utils/execution/ 调用工具.\n- 被依赖: 主代理/子代理执行层与 UI 的 MCP 配置管理界面.\n\n避坑指南:\n- 工具权限必须受 agent profile 限制(包括限制可编辑文件类型的字段),避免越权编辑.\n- MCP server 连接生命周期要与会话/进程生命周期对齐,避免残留连接导致资源泄漏.\n- 不要在此层引入具体模型渠道差异,仅做工具协议与运行时管理.",
      "createdAt": "2026-02-22T12:51:00.039",
      "updatedAt": "2026-02-22T12:51:00.039"
    }
  ],
  "source/mcp/utils/filesystem/batch-operations.utils.ts": [
    {
      "id": "notebook-1770864631005_batch",
      "filePath": "source/mcp/utils/filesystem/batch-operations.utils.ts",
      "note": "职责: 批量文件操作公共执行器,负责逐文件执行与结果聚合.\n接口摘要: executeBatchOperation 输入 parseParams,executeSingle,mapResult,输出 results,totalFiles,successCount,failureCount.\n依赖拓扑: source/mcp/filesystem.ts 的 editFile/editFileBySearch 共用该层.\n避坑指南:\n- 本层是通用执行器,不得引入任何 UI 语义(showMcpPanel,mcpPanelSource)或屏幕路由概念.\n- 不在此处做工具禁用/权限过滤,上游应传入已完成\"服务级禁用 + 代理级权限\"筛选后的最终执行集合.\n- 与本需求相关: 流式 API idle timeout/断开丢弃属于网络流处理层,与批量文件操作无关.不要将任何 stream 健壮性逻辑塞进 batch executor,避免职责污染.",
      "createdAt": "2026-02-12T10:50:31.000",
      "updatedAt": "2026-02-13T10:30:20.438"
    }
  ],
  "source/mcp/filesystem.ts": [
    {
      "id": "notebook-1770864631004_fsmcp",
      "filePath": "source/mcp/filesystem.ts",
      "note": "职责: 文件编辑真实执行层,承载 editableFileSuffixes 拦截规则的统一落点.\n接口摘要: editFile/editFileBySearch 支持单文件与批量,输出 diff,diagnostics 与统计结果.\n依赖拓扑: 上游由 mcpToolsManager.ts 调用,批量聚合依赖 batch-operations.utils.ts.\n避坑指南:\n- 本层保持纯执行语义,不参与任何 UI 导航(showMcpPanel,mcpPanelSource,source)决策.\n- 拒绝项在批量中落成 success:false + 固定文案,保留部分成功.\n- 工具执行前应同时受\"MCP 服务开关(全局总闸)\"与\"代理工具权限(代理分闸)\"影响.\n- 服务级禁用应在 mcpToolsManager/disabledBuiltInTools 形成不可路由的最终集合,本层只对已授权且已启用的工具执行,不负责读取/写入全局禁用文件.\n- 与本需求相关: 流式 API idle timeout/断开丢弃属于网络请求层与 utils/core 的职责,不得在工具执行层实现任何与 HTTP/stream 相关的超时或重试,避免跨域耦合.",
      "createdAt": "2026-02-12T10:50:31.000",
      "updatedAt": "2026-02-13T10:33:36.781"
    }
  ],
  "source/prompt/": [
    {
      "id": "notebook-1771735859888_jrblgmfub",
      "filePath": "source/prompt/",
      "note": "职责: 提示词系统(SSoT for prompting).承载系统提示词模板、共享片段(shared),以及与主/子代理角色定义提示词的拼装约束.\n\n接口摘要:\n- 输入: 当前调用上下文(主/子代理,会话信息,环境信息),以及可选的 customSystemPromptOverride(string[]).\n- 输出: 供模型适配器(source/api/*)使用的 system prompt 片段(可能为多条,顺序敏感).\n\n依赖拓扑:\n- 依赖: source/utils/agentsPromptUtils.ts(环境信息片段),主代理配置(MainAgentManager)提供的 role definition.\n- 被依赖: 对话执行层(execution)与各模型适配器在组装请求时引用.\n\n避坑指南:\n- 主/子代理隔离硬约束: 角色定义提示词只来自当前 agent profile,不得跨注入.\n- 多条 system prompt 必须保持顺序敏感,跨渠道(anthropic/chat/gemini/responses)语义等价.\n- 不要在此目录写 UI 文案或业务状态机逻辑,仅做 prompting 相关拼装.",
      "createdAt": "2026-02-22T12:50:59.888",
      "updatedAt": "2026-02-22T12:50:59.888"
    }
  ],
  "source/test/sse-client/": [
    {
      "id": "notebook-1771478149195_7bs0m83xf",
      "filePath": "source/test/sse-client/",
      "note": "职责: 浏览器端 SSE 客户端示例(开发/联调用途),用于验证 Snow CLI 的 SSE 服务协议(connected,message,agent_list,agent_switched,error 等)与会话管理 API.\n\n不该做什么:\n- 不作为生产级前端架构,不引入复杂框架/构建工具.\n- 不实现服务端业务逻辑,仅消费协议并展示.\n\n接口摘要:\n- 输入: EventSource(/events) 事件流 + fetch(/message,/session/*) 等 HTTP 调用.\n- 输出: DOM UI(聊天消息,状态,会话列表,主代理选择器) + 控制台/事件日志.\n\n依赖拓扑:\n- 依赖: source/api/sse-server.ts 的协议契约,source/utils/sse/sseManager.ts 的事件/错误码实现,docs/usage/zh/20.SSE服务模式.md,requirements/SSE客户端适配主代理.md.\n- 被依赖: 无(仅示例).\n\n避坑指南:\n- 兼容性: 必须对未知 event.type 静默忽略,避免服务端新增事件导致客户端崩溃.\n- 断线重连: 断线时必须清理 agents/currentAgentId/isSwitchingAgent 等连接态,并禁用选择器;但可选择保留 preferredAgentIdForNewSession,便于重连后新建会话继续使用预选主代理.\n- 主代理切换状态机: UI 不得仅凭 select change 更新 currentAgentId,必须等待 agent_switched 确认;切换失败(包括 error 无 errorCode)必须回滚到 lastConfirmedAgentId 并解锁 isSwitchingAgent/requestedAgentId,否则 UI 会卡死.\n- 会话边界: 切换主代理必须以 sessionId 为边界,客户端已知 currentSessionId 时必须随 switch_agent 一并发送,避免依赖连接绑定产生歧义.",
      "createdAt": "2026-02-19T13:15:49.195",
      "updatedAt": "2026-02-20T00:02:06.436"
    }
  ],
  "source/test/sse-client/app.js": [
    {
      "id": "notebook-1771478149329_cgfw81aim",
      "filePath": "source/test/sse-client/app.js",
      "note": "职责: 浏览器端 SSE 客户端示例的主逻辑.负责连接管理(EventSource),统一事件分发(handleEvent),消息发送(chat,abort,rollback,tool/user_question 响应,switch_agent),会话列表与当前会话状态维护,以及聊天 UI 渲染.\n\n主代理扩展(已落地的状态机约束):\n- 状态字段: agents,currentAgentId,lastConfirmedAgentId,isSwitchingAgent,requestedAgentId,preferredAgentIdForNewSession.\n- 原则: UI 不得仅凭 select change 就更新 currentAgentId,必须等待服务端 agent_switched 确认;失败则回滚到 lastConfirmedAgentId.\n\n接口摘要:\n- 输入: EventSource(/events) 推送(agent_list,agent_switched,error 等) + fetch(/message,/session/create,/session/load) 等 HTTP 调用.\n- 输出: DOM UI(主代理选择器,系统消息,事件日志).\n\n依赖拓扑:\n- 依赖: source/api/sse-server.ts 的协议契约,source/utils/sse/sseManager.ts 的错误码与事件实现,requirements/SSE客户端适配主代理.md.\n- 被依赖: 无(仅示例).\n\n避坑指南:\n- 防 UI 卡死: 切换中收到 error 时,即使 errorCode 缺失也必须执行回滚与解锁(currentAgentId=lastConfirmedAgentId,isSwitchingAgent=false,requestedAgentId=null,renderMainAgentSelect),否则选择器会永久 disabled.\n- 网络异常鲁棒: switch_agent 发送失败提示使用 error?.message || String(error),覆盖非 Error 抛出场景.\n- 预选逻辑: 无 sessionId 时允许预选 preferredAgentIdForNewSession,仅在新建会话时作为 initialAgentId 传给服务端,不要提前发送 switch_agent.\n- 向后兼容: handleEvent 必须对未知 event.type 静默忽略,避免服务端协议扩展导致示例崩溃.",
      "createdAt": "2026-02-19T13:15:49.329",
      "updatedAt": "2026-02-20T00:02:06.565"
    }
  ],
  "source/test/sse-client/dialogs.js": [
    {
      "id": "notebook-1771478149697_iovnxgo37",
      "filePath": "source/test/sse-client/dialogs.js",
      "note": "职责: SSE 客户端示例的对话框集合.负责工具确认,用户问题等弹窗渲染与回传,通过 sendResponse 与服务端交互.\\n主代理扩展关联点: \\n- 若主代理切换失败需要弹窗提示,应复用统一的错误提示入口(若已有 alert/toast 机制,优先保持一致),避免在 app.js 散落 prompt/alert.\\n避坑指南: \\n- dialogs.js 保持与具体 event.type 解耦,仅接受渲染所需的结构化数据;事件到对话框的映射由 app.js(handleEvent)负责.\\n- 异步按钮回调必须 try/catch 并恢复 modal 状态,避免异常导致 UI 卡死.",
      "createdAt": "2026-02-19T13:15:49.697",
      "updatedAt": "2026-02-19T13:15:49.697"
    }
  ],
  "source/test/sse-client/index.html": [
    {
      "id": "notebook-1771478149452_7h0fhq8s9",
      "filePath": "source/test/sse-client/index.html",
      "note": "职责: SSE 客户端示例页面骨架,承载基础布局(连接区,会话列表,聊天面板头部与消息区)以及各控件 DOM id 约定,供 app.js 绑定事件与更新 UI.\\n主代理扩展(本需求): \\n- 在聊天面板头部右侧,紧邻\"新建会话\"按钮,增加主代理选择器(select#mainAgentSelect)与 loading/未连接占位文案.\\n接口摘要: \\n- 输出: 稳定的 DOM 结构与元素 id,不包含业务逻辑.\\n避坑指南: \\n- 仅做语义化结构,避免内联脚本与复杂样式,保持 app.js 可独立演进.\\n- 新增控件必须保持 id 唯一且与 app.js 常量一致,否则会导致事件绑定失败且难排查.",
      "createdAt": "2026-02-19T13:15:49.452",
      "updatedAt": "2026-02-19T13:15:49.452"
    }
  ],
  "source/test/sse-client/style.css": [
    {
      "id": "notebook-1771478149573_hpypjn8r8",
      "filePath": "source/test/sse-client/style.css",
      "note": "职责: SSE 客户端示例的样式表,控制布局与视觉反馈(连接状态,按钮,聊天消息,loading 等).\\n主代理扩展(本需求): \\n- 为主代理选择器提供紧凑样式,与\"新建会话\"按钮同一行右侧对齐.\\n- 提供 switching/loading 的视觉态(如 disabled + spinner 或 opacity),以及未连接态的占位文案样式.\\n避坑指南: \\n- 避免使用影响全局的 tag 选择器,优先用 class/id 作用域,防止破坏既有聊天样式.\\n- loading 状态应可无障碍(禁用 select,同时提供文本提示),不要只靠颜色变化.",
      "createdAt": "2026-02-19T13:15:49.573",
      "updatedAt": "2026-02-19T13:15:49.573"
    }
  ],
  "source/types/MainAgentConfig.ts": [
    {
      "id": "notebook-1770864631001_maincfg",
      "filePath": "source/types/MainAgentConfig.ts",
      "note": "职责: 定义主代理配置类型边界,承载工具权限与文件编辑限制等字段语义,不负责执行拦截.\n接口摘要: 输入来自 MainAgentConfigIO 与 MainAgentConfigScreen 的配置写入,输出给 MainAgentManager 作为 currentConfig.\n关键架构决策(渐进式权限模型):\n- 用户视角的工具可用性 = MCP 服务开关(全局总闸) + 代理工具权限(代理分闸).\n- 层级1(全局): MCP 内置服务禁用开关(见 disabledBuiltInTools)控制某些服务及其全部工具在整个应用中不可见/不可用.\n- 层级2(代理级): 本类型中的工具权限字段仅对当前代理生效,用于进一步收敛可用工具集合.\n依赖拓扑: MainAgentManager.ts 与 MainAgentConfigScreen.tsx 依赖该类型.\n避坑指南:\n- 保持类型层纯粹,不要将 UI 导航状态(如 showMcpPanel,mcpPanelSource 或 source)引入配置类型.\n- 工具权限字段命名应稳定,避免与服务级禁用开关混淆.\n- UI 层做工具过滤后,配置持久化层仍需要二次清理,防止历史配置残留.\n备注:\n- 与\"流式 API 空闲超时/断开后丢弃\"无关.该机制固定 3 分钟,属于 api adapters + utils/core(streamGuards,retryUtils),不可配置,不要把 idleTimeout 等字段加入 MainAgentConfig,避免把健壮性机制变成用户配置负担.",
      "createdAt": "2026-02-12T10:50:31.000",
      "updatedAt": "2026-02-13T11:51:18.394"
    }
  ],
  "source/ui/": [
    {
      "id": "notebook-1771735836915_9iyi2nqvn",
      "filePath": "source/ui/",
      "note": "职责: TUI UI 层(基于 Ink/React).提供 screens/pages/components/themes 等,负责用户交互与状态展示.\n\n不该做什么:\n- 不直接做模型请求/流式解析/重试等网络健壮性逻辑.\n- 不直接读写主代理/子代理配置文件(toml/json),通过 utils/config 与 manager 提供的接口.\n\n依赖拓扑:\n- 依赖: source/utils/ui/* 的 UI 辅助逻辑,以及 i18n/theme 等.\n- 被依赖: source/app.tsx,source/cli.tsx.\n\n避坑指南:\n- 避免在多个 screen 同时注册 useInput 导致按键冲突,用条件渲染确保同一时刻只有一个焦点层处理 Esc/Enter.\n- UI 状态与业务状态分离: UI 只持有显示所需的派生状态,会话/代理/执行状态以 utils 层为准.",
      "createdAt": "2026-02-22T12:50:36.915",
      "updatedAt": "2026-02-22T12:50:36.915"
    }
  ],
  "source/ui/components/panels/MCPInfoPanel.tsx": [
    {
      "id": "notebook-1770950000002_mcpinfopanel",
      "filePath": "source/ui/components/panels/MCPInfoPanel.tsx",
      "note": "职责: MCP 服务管理面板,展示服务状态,支持重连服务,切换服务启用/禁用状态.\n不该做什么:\n- 不直接修改业务配置(代理工具权限,模型选择等),仅处理 MCP 服务层面的开关/重连.\n- 不把 UI 状态渗透进执行层,所有启用状态最终落在 disabledBuiltInTools(.snow/disabled-builtin-tools.json)或外部 mcp.json.\n接口摘要:\n- Props: { source?: 'chat' | 'mcpConfig'; onClose: () => void }.\n- 键盘交互: Tab 切换服务启用/禁用,Enter 触发重连,Esc 优先关闭并调用 onClose.\n依赖拓扑:\n- 依赖: mcpToolsManager(服务列表/状态/重连),disabledBuiltInTools(内置服务禁用读写),useI18n(文案).\n- 被依赖: PanelsManager(从 ChatScreen 面板体系打开),MCPConfigScreen(从配置界面直接打开).\n关键架构决策:\n- source prop 当前未使用,仅作为未来差异化导航行为预留(例如关闭后回到 chat 或 config 的不同焦点管理).\n- 内置服务 vs 外部 MCP 服务禁用机制不同: 内置服务走 disabled-builtin-tools.json,外部服务走 mcp.json.\n避坑指南:\n- Esc 必须优先处理并调用 onClose,否则会被上层 useInput 吞掉导致无法返回.\n- 禁用/启用服务后需触发工具缓存刷新(由 mcpToolsManager 层提供的刷新/重建机制),避免 UI 与执行工具列表不一致.",
      "createdAt": "2026-02-13T09:40:00.000",
      "updatedAt": "2026-02-13T09:40:00.000"
    }
  ],
  "source/ui/components/panels/PanelsManager.tsx": [
    {
      "id": "notebook-1770950000004_panelsmanager",
      "filePath": "source/ui/components/panels/PanelsManager.tsx",
      "note": "职责: 面板装配器,根据 usePanelState 提供的状态与上层透传的 props,条件渲染各类面板(MCP,Session,Models 等).\n不该做什么:\n- 不在此处维护面板 state(归 usePanelState),也不直接读写配置文件.\n- 不在 ChatScreen 之外复用,避免把 20+ props 体系扩散到独立 screen.\n- 不在此处实现任何网络/stream 健壮性逻辑(如 idle timeout,重试等),避免 UI 层与 network/core 耦合.\n接口摘要:\n- Props: 20+ 个面板相关 props(各面板所需的回调/数据/状态).\n- 输出: 按 showXxxPanel 状态条件渲染对应 Panel,并负责向子面板透传 props.\n依赖拓扑:\n- 依赖: usePanelState 的状态,以及各 Panel 组件(含 MCPInfoPanel,可能 lazy load).\n- 被依赖: ChatScreen(唯一装配入口).\n关键架构决策:\n- MCPInfoPanel 采用 lazy loading,减少首次渲染成本.\n- 通过 props 透传,而不是引入全局 store,保持状态来源清晰可追踪.\n避坑指南:\n- 由于 props 数量巨大,新增面板字段时必须同步更新 PanelsManager 的 props 类型与所有调用方,避免出现\"面板不显示\"的隐性断链.\n- 仅做\"装配\",不要在此处实现键盘快捷键,避免与各面板内部 useInput 冲突.",
      "createdAt": "2026-02-13T09:40:00.000",
      "updatedAt": "2026-02-13T11:35:18.419"
    }
  ],
  "source/ui/pages/MCPConfigScreen.tsx": [
    {
      "id": "notebook-1770950000001_mcpcfgscreen",
      "filePath": "source/ui/pages/MCPConfigScreen.tsx",
      "note": "职责: MCP 配置界面,提供全局/项目级配置编辑入口,以及 MCP 服务管理面板(MCPInfoPanel)入口.\n不该做什么:\n- 不承担 MCP 服务注册/发现/调用等执行逻辑(归 mcpToolsManager).\n- 不把 ChatScreen 的面板状态体系(usePanelState)强行复用到本 Screen,避免引入 20+ props 的 PanelsManager 耦合.\n- 不在面板打开时继续渲染并响应本页按键,避免 Ink 多 useInput 冲突与 Esc 返回链路分叉.\n接口摘要:\n- Props: { onBack: () => void; onSave: () => void }.\n- UI: 渲染配置菜单项,可跳转至全局/项目配置编辑器,可打开 MCPInfoPanel 面板.\n依赖拓扑:\n- 依赖: useTheme,useI18n,MCPInfoPanel,apiConfig(全局/项目配置读取与 editor 打开).\n- 被依赖: WelcomeScreen(作为入口 Screen).\n关键架构决策:\n- 面板状态采用本地 useState 管理(showMcpPanel),不使用 usePanelState.\n- 面板打开时通过条件渲染完全隐藏配置 UI,并屏蔽本页 useInput,确保 Esc 返回链路单一且避免 useInput 冲突.\n避坑指南:\n- 面板打开后必须优先处理 Esc 并交由 MCPInfoPanel.onClose 收口关闭逻辑.\n- 仅负责\"入口与导航\",不要在此处做服务启用/禁用的读写与缓存刷新.\n备注:\n- 与\"流式 API 空闲超时/断开后丢弃\"无关.该机制属于 api adapters + utils/core(streamGuards,retryUtils),且固定 3 分钟不可配置,不应暴露为 UI 开关.",
      "createdAt": "2026-02-13T09:40:00.000",
      "updatedAt": "2026-02-13T11:50:59.239"
    }
  ],
  "source/utils/": [
    {
      "id": "notebook-1771735837045_ax74drms8",
      "filePath": "source/utils/",
      "note": "职责: 核心业务与通用能力层.包含对话执行(execution),会话(session),SSE(sse),模型调用与流控制(core),配置读写(config),命令(commands),事件(events)等.\n\n接口摘要:\n- 输入: UI/CLI 层传入的用户指令与上下文.\n- 输出: 对话结果,状态变更事件,以及对外协议输出(SSE 事件等).\n\n依赖拓扑:\n- 依赖: source/api/ 作为模型渠道适配器.\n- 被依赖: source/ui/ 与 CLI 入口.\n\n避坑指南:\n- 任何跨会话的可变状态必须显式按 sessionId/connectionId 分片,禁止隐式单例导致串扰.\n- 流式输出必须统一使用 streamGuards/idle timeout/abandoned 丢弃策略,避免 abort 后 chunk 外泄.\n- 主/子代理提示词隔离是硬约束: 角色定义提示词只来自各自 profile,自定义 system prompt 仅影响本次调用且不得跨注入.",
      "createdAt": "2026-02-22T12:50:37.045",
      "updatedAt": "2026-02-22T12:50:37.045"
    }
  ],
  "source/utils/config/disabledBuiltInTools.ts": [
    {
      "id": "notebook-1770950000006_disabledbuiltintools",
      "filePath": "source/utils/config/disabledBuiltInTools.ts",
      "note": "职责: 内置 MCP 服务禁用管理,负责读写 .snow/disabled-builtin-tools.json,并提供按启用服务过滤工具的能力.\n不该做什么:\n- 不管理外部 MCP 服务(外部服务禁用由 mcp.json 控制).\n- 不承担 UI 交互,仅提供纯配置读写与过滤函数.\n接口摘要:\n- 输入: serviceName 或 tools 列表.\n- 输出: isServiceEnabled,getEnabledBuiltInServices(),filterToolsByEnabledServices() 等,以及禁用文件的持久化读写.\n依赖拓扑:\n- 被依赖: mcpToolsManager(裁剪服务/工具),MainAgentConfigScreen/SubAgentConfigScreen(过滤工具展示).\n关键架构决策:\n- 内置服务禁用是\"全局总闸\",优先级高于任何代理级工具权限,且不应写入各代理 TOML 配置.\n避坑指南:\n- 修改禁用文件后需触发 MCP 工具缓存刷新,否则会出现 UI 已禁用但工具仍可调用的状态.\n- 服务名必须与 mcpToolsManager 的 hardcoded 列表一致,避免出现\"永远启用\"的幽灵服务.\n备注:\n- 与\"流式 API 空闲超时/断开后丢弃\"无关.该机制属于 api adapters + utils/core(streamGuards,retryUtils),固定 3 分钟不可配置,不应在配置领域增加 idleTimeout 开关,避免职责扩张.",
      "createdAt": "2026-02-13T09:40:00.000",
      "updatedAt": "2026-02-13T11:51:18.242"
    }
  ],
  "source/utils/config/editableFileSuffixes.ts": [
    {
      "id": "notebook-1770864631010_suffixutils",
      "filePath": "source/utils/config/editableFileSuffixes.ts",
      "note": "职责: editableFileSuffixes 规则工具层,统一规范化/解析/格式化/后缀提取/权限判定逻辑.\n接口摘要: normalize/parse/stringify/getFileSuffix/isAllowed 等纯函数.\n依赖拓扑: 被 source/mcp/filesystem.ts 与配置 UI 调用.\n避坑指南:\n- 本层是纯工具函数集合,不得引入 UI 面板状态(showMcpPanel,mcpPanelSource)或屏幕路由逻辑.\n- 权限模型需区分: agent 级(可编辑后缀,工具权限)与 service 级(全局禁用 MCP 内置服务).该工具仅处理 agent 级文件编辑限制,不处理服务禁用.\n- 与\"流式 API 空闲超时/断开后丢弃\"无关.不要将该需求的任何配置开关或常量引入 editableFileSuffixes,避免把网络健壮性机制错误地暴露为用户配置.",
      "createdAt": "2026-02-12T15:30:00.000",
      "updatedAt": "2026-02-13T11:35:33.986"
    }
  ],
  "source/utils/config/subAgentConfig.ts": [
    {
      "id": "notebook-1770864631002_subcfg",
      "filePath": "source/utils/config/subAgentConfig.ts",
      "note": "职责: 管理子代理配置的读取,创建,更新和持久化,是子代理侧工具权限与编辑限制字段的存储入口.\n接口摘要: createSubAgent/updateSubAgent 接收 UI 字段并写入 TOML,getSubAgent 提供运行态读取.\n关键架构决策(渐进式权限模型):\n- 子代理可用工具集合 = MCP 服务开关(全局总闸) + 子代理工具权限(代理分闸).\n- 服务级禁用不写入 sub-agents.toml,由全局禁用文件统一管理,并在加载/保存时清理已禁用服务的工具.\n依赖拓扑: SubAgentConfigScreen.tsx 调用写入,subAgentExecutor.ts 通过 getSubAgent 读取执行时配置.\n避坑指南:\n- 配置层不应与 UI 面板导航状态(showMcpPanel,mcpPanelSource,source)耦合.\n- 更新/创建逻辑需复用同一套工具过滤/规范化逻辑.\n- UI 层做工具过滤后,配置持久化层仍需要二次清理,防止历史配置残留.\n- 不要在本层实现任何\"打开 MCPInfoPanel\"之类的 UI 行为,避免跨域耦合.\n- 与本需求相关: 流式 API 的空闲超时(固定3分钟)不可配置,因此不要为子代理增加 idleTimeout 等配置字段,让网络健壮性机制对主/子代理保持一致.\n备注: 之前笔记中出现 editableFileSuffixes 的单一职责描述,不够准确,已修正为通用子代理配置管理.",
      "createdAt": "2026-02-12T10:50:31.000",
      "updatedAt": "2026-02-13T10:31:52.970"
    }
  ],
  "source/utils/core/streamGuards.ts": [
    {
      "id": "notebook-1770953800000_streamguards",
      "filePath": "source/utils/core/streamGuards.ts",
      "note": "职责: core 层流式读取保护器,提供统一的 idle timeout 检测(固定 STREAM_IDLE_TIMEOUT_MS=180000),abandoned 丢弃屏障,以及将超时异常从定时器回调安全传递到读取循环的机制.\n不该做什么:\n- 不在 setInterval/setTimeout 回调里直接 throw,也不允许 onTimeout 的异常冒泡到事件循环,避免触发 uncaughtException.\n- 不在本模块实现重试/退避策略,只提供可被上层(withRetryGenerator)消费的信号与错误.\n- 不把 idle timeout 作为用户配置项暴露;生产代码不应覆盖 idleTimeoutMs,以确保所有适配器行为一致.\n接口摘要:\n- STREAM_IDLE_TIMEOUT_MS: number,3 分钟常量.\n- StreamIdleTimeoutError: Error 子类,name 固定为 StreamIdleTimeoutError,供 retryUtils 优先通过 error.name 判定可重试.\n- StreamGuard: {abandon,isAbandoned,getTimeoutError,touch,dispose}.\n- createIdleTimeoutGuard({reader?,onTimeout?,idleTimeoutMs?}): StreamGuard.\n  - onTimeout 可以 throw,但异常会被 guard 捕获并保存为 timeoutError.\n  - 调用方必须在读取循环中检查 guard.getTimeoutError() 并在循环上下文 throw,确保被业务 try/catch 捕获并进入重试链路.\n依赖拓扑:\n- 依赖: utils/core/logger.ts(仅日志).\n- 被依赖: source/api/chat.ts,responses.ts,anthropic.ts,gemini.ts 的流式读取循环.\n- 协作: utils/core/retryUtils.ts 通过 error.name===StreamIdleTimeoutError 判定可重试.\n避坑指南:\n- Node.js 定时器回调里的 throw 不会被外层 parseSSEStream 的 try/catch 捕获,会变成 uncaughtException,并在本项目中可能触发 process.exit(1).\n- logger.warn/error 最终会走 fs.appendFileSync 写文件,可能同步抛错;定时器回调内的日志也必须被 try/catch 覆盖,禁止异常冒泡到事件循环.\n- 当前实现已在 setInterval 回调外层使用全量 try/catch,覆盖 logger.warn,reader.cancel,onTimeout 等所有路径,确保任何异常都不会冒泡.\n- 超时触发重试的正确模式: 定时器只做 abandon/cancel + 记录 timeoutError,读取循环负责检测 getTimeoutError 并 throw.\n- 适配器必须实现 getTimeoutError 检查,否则超时错误会被吞掉(常见表现: reader.cancel/done 后静默结束,或下游一直等待结束事件).\n- 文档注释/示例已更新: 示例现在明确演示 onTimeout 可以 throw(由 guard 捕获并保存),调用方必须在读取循环中检查 guard.getTimeoutError() 并在循环上下文 throw,避免误导调用方.",
      "createdAt": "2026-02-13T12:30:00.000",
      "updatedAt": "2026-02-13T13:26:27.899"
    }
  ],
  "source/utils/execution/mcpToolsManager.ts": [
    {
      "id": "notebook-1770950000005_mcptoolsmanager",
      "filePath": "source/utils/execution/mcpToolsManager.ts",
      "note": "职责: MCP 工具管理核心,管理内置服务与外部 MCP 服务的注册,发现,调用与状态聚合,向执行层提供统一的工具视图.\n不该做什么:\n- 不引入 UI 导航状态(showMcpPanel,mcpPanelSource,source)或 screen/panel 概念.\n- 不在此处实现配置 UI,仅提供可被 UI 消费的状态与操作 API.\n接口摘要:\n- 输入: MCP 服务配置(mcp.json/内置 hardcoded 列表),以及工具调用请求(tool name + args + context).\n- 输出: 可用工具列表,服务状态(连接/错误),工具执行结果.\n依赖拓扑:\n- 依赖: disabledBuiltInTools(内置服务启用状态),mcpConfig(外部服务配置).\n- 被依赖: MCPInfoPanel(服务状态/重连/开关),toolExecutor(执行转发),各 Agent(工具发现与执行).\n关键架构决策:\n- 内置服务列表 hardcoded: 新增/调整内置服务必须修改本文件并同步 disabledBuiltInTools 的服务名约束.\n- 统一维护\"服务 <-> 工具\"映射关系,并在此处裁剪被禁用服务对应的工具集合.\n避坑指南:\n- 服务禁用状态需同时检查 disabledBuiltInTools,避免只隐藏 UI 但执行仍可调用.\n- 切换服务启用/禁用后应刷新/重建工具缓存,确保运行态与 UI 一致.\n- 外部服务与内置服务禁用逻辑不同,不要混用配置文件.\n备注:\n- 与\"流式 API 空闲超时/断开后丢弃\"无关.该机制属于 api adapters + utils/core(streamGuards,retryUtils),并且固定 3 分钟不可配置.本文件只需透传 abortSignal 与执行请求,避免把网络健壮性与工具编排耦合.",
      "createdAt": "2026-02-13T09:40:00.000",
      "updatedAt": "2026-02-13T11:53:45.362"
    }
  ],
  "source/utils/execution/subAgentExecutor.ts": [
    {
      "id": "notebook-1770864631008_subexec",
      "filePath": "source/utils/execution/subAgentExecutor.ts",
      "note": "职责: 子代理运行时装配器,加载子代理配置并执行工具调用循环.\n接口摘要: getSubAgent(agentId)->agent配置,executeMCPTool 执行具体工具并回传结果.\n依赖拓扑: 上游依赖 subAgentConfig.ts,下游依赖 mcpToolsManager.ts 与 filesystem.ts.\n避坑指南:\n- 子代理运行态不应处理任何 UI 导航(source)逻辑.\n- 工具可见性由\"MCP 服务全局开关(全局总闸)\"与\"代理工具权限(代理分闸)\"共同决定;全局服务禁用由 mcpToolsManager/disabledBuiltInTools 统一裁剪,运行态只消费最终可执行工具集合.\n备注:\n- 与\"流式 API 空闲超时/断开后丢弃\"无关.该机制属于 api adapters + utils/core(streamGuards,retryUtils).子代理执行器仅负责透传 abortSignal/取消语义.",
      "createdAt": "2026-02-12T10:50:31.000",
      "updatedAt": "2026-02-13T11:53:27.764"
    }
  ],
  "source/utils/execution/toolExecutor.ts": [
    {
      "id": "notebook-1770864631011_toolexec",
      "filePath": "source/utils/execution/toolExecutor.ts",
      "note": "职责: 工具执行编排层,负责单个工具调用的完整生命周期管理,包括前置钩子/实际执行/后置钩子.\n接口摘要: executeToolCall(ToolCall,executionContext) -> ToolResult.透传 executionContext 给 mcpToolsManager.executeMCPTool.\n依赖拓扑: 上游被 useConversation.ts 和 subAgentExecutor.ts 调用,下游依赖 mcpToolsManager.ts.\n避坑指南:\n- 本层必须保持通用,不得引入 UI 面板状态(showMcpPanel,mcpPanelSource)或 screen 路由概念.\n- 工具可见性由\"MCP 服务全局开关(全局总闸)\"与\"代理工具权限(代理分闸)\"共同决定;服务级禁用应在 mcpToolsManager/disabledBuiltInTools 过滤,本层只执行上游已筛选后的调用.\n备注:\n- 与\"流式 API 空闲超时/断开后丢弃\"无关.该机制属于 api adapters + utils/core(streamGuards,retryUtils),这里仅保留边界说明,不记录实现细节.",
      "createdAt": "2026-02-12T15:30:00.000",
      "updatedAt": "2026-02-13T11:52:29.700"
    }
  ],
  "source/utils/session/sessionManager.ts": [
    {
      "id": "notebook-1770979051063_ghqgo41jg",
      "filePath": "source/utils/session/sessionManager.ts",
      "note": "职责: 会话生命周期管理.负责创建/获取/保存会话对象(sessionId),维护跨消息的会话上下文(对话历史,快照信息等),为 TUI 与 SSE 提供统一的会话复用能力.\n本需求与 SSE 集成点:\n- sessionId 作为隔离边界: 每个 sessionId 拥有独立的 currentMainAgentId(由 SSEManager 维护或由 sessionManager 扩展承载).\n- SSE 连接初始未绑定 session,在首次 chat/image 或显式指定 sessionId 时建立绑定.\n不该做什么:\n- 不直接处理 SSE 连接与事件协议,也不负责推送 agent_list.\n接口摘要:\n- getOrCreateSession(sessionId?): 返回 session 对象.\n- 与 rollback/snapshot 相关的 API 供 SSEManager 调用.\n避坑指南:\n- 同一 sessionId 可能被多个 SSE 连接复用,任何会话级状态修改必须是幂等且线程安全(至少避免 Map 覆盖导致状态丢失).\n- 如果后续决定把 currentMainAgentId 放进 session 持久化,需明确: 是否写入磁盘,是否跨进程/重启保留;默认建议仅内存态,保持行为简单.",
      "createdAt": "2026-02-13T18:37:31.063",
      "updatedAt": "2026-02-13T18:37:31.063"
    }
  ],
  "source/utils/sse/": [
    {
      "id": "notebook-1771495044206_arra3wr1q",
      "filePath": "source/utils/sse/",
      "note": "职责: SSE 业务编排层.负责 SSEServer 的启动/停止,连接生命周期回调,客户端消息分发(chat,image,abort,rollback,switch_agent 等),以及把执行层输出封装为 SSEEvent 推送回对应连接.\n\n接口摘要:\n- 输入: source/api/sse-server.ts 的回调(messageHandler,connectionCreatedHandler,sessionCreatedHandler,sessionBoundHandler,connectionClosedHandler)与 sessionManager/mainAgentManager.\n- 输出: SSEEvent(connected,message,tool_*,agent_list,agent_switched,error 等).\n\n依赖拓扑:\n- 上游: source/api/sse-server.ts.\n- 下游: source/utils/session/sessionManager.ts,source/utils/MainAgentManager.ts,对话执行器(useConversation/toolExecutor 等).\n\n避坑指南:\n- 会话隔离: 所有状态以 sessionId 为 key,避免 connectionId 导致跨会话串扰.\n- 映射一致性: 使用 connectionSessionMap 作为\"业务层镜像\",来源于 SSEServer 的 bind 与 sessionBoundHandler 通知,禁止从 (server as any).sessionConnections 穿透读取.\n- 回调职责清晰: sessionBoundHandler 回调内仅同步映射(bindSessionToConnection mirror),不要做额外 bind/广播,避免竞态.\n- 严格校验的时序风险: switch_agent 依赖 connectionSessionMap,必须确保 create/load 路径也会同步映射(通过 sessionBoundHandler).",
      "createdAt": "2026-02-19T17:57:24.206",
      "updatedAt": "2026-02-19T17:57:24.206"
    }
  ],
  "source/utils/sse/sseManager.ts": [
    {
      "id": "notebook-1770979050800_ws9seqhn5",
      "filePath": "source/utils/sse/sseManager.ts",
      "note": "职责: SSE 服务编排与会话交互管理.负责启动/停止 SSEServer,处理 ClientMessage(chat,image,abort,rollback,交互响应,switch_agent 等),并与 sessionManager/useConversation 对接实现会话级对话与流式输出.\n\n核心架构决策(会话隔离,关键约束):\n- 一个 sessionId 只对应一个 SSE 连接(不支持同 session 多连接复用).\n- 因此任何\"会话级\"状态都必须以 sessionId 为 key,且只影响该 sessionId 当前绑定的单个 connectionId.\n\n关键状态/机制(主代理适配的事实源):\n- sessionAgentIds: Map<string,string>,sessionId -> agentId.作为会话级主代理选择的唯一事实源,默认 defaultAgentId='general'.\n- connectionSessionMap: Map<string,string>,connectionId -> sessionId.业务层维护的绑定镜像,禁止再从 (server as any).sessionConnections 穿透读取.\n- sessionBoundHandler: SSEServer 在 /session/create,/session/load 完成 bindSessionToConnection 后触发的回调.本模块在 start() 注册 setSessionBoundHandler,回调内仅调用 bindSessionToConnection 同步 connectionSessionMap,用于修复 switch_agent 严格校验时序下的 session_not_found 误判.\n- pendingInteractions: 等待 tool_confirmation/user_question 的交互队列.若涉及 busy 判定,PendingInteraction 必须携带 sessionId,且 busy 判定必须精确匹配 sessionId.\n\n本模块职责(与主代理选择相关):\n- 连接建立/会话绑定后下发 agent_list({agents,currentAgentId}),为客户端提供可选项.\n- 处理 switch_agent 客户端消息,完成会话级 agentId 切换并推送 agent_switched,或返回 error(含 errorCode 与 availableAgents).\n- 统一错误事件结构,必要时附带 availableAgents,便于客户端自恢复与重新选择.\n\n不该做什么:\n- 不在此处解析/加载 main-agents.toml 细节,通过 MainAgentManager 提供的查询接口获取可用代理列表与配置.\n- 不把主代理状态存成全局单例字段导致跨 session 串扰.\n\n接口摘要(与切换相关):\n- handleSwitchAgentRequest({ agentId },{ connectionId,sendEvent }):\n  - 通过 connectionSessionMap 获取 sessionId,不存在则 errorCode=session_not_found.\n  - 校验 agentId: 空 -> invalid_agent_id;格式不匹配 ^[a-z0-9_-]+$ -> invalid_agent_id_format;不在 listAvailableAgents -> agent_not_found.\n  - busy 判定: 若该 sessionId 存在进行中的对话(sessionControllers)或该 sessionId 有 pendingInteractions,则 errorCode=agent_busy.\n  - 通过 MainAgentManager.getAgentConfig(agentId) 做最终存在性校验,并更新 sessionAgentIds.set(sessionId,agentId).\n  - 推送 agent_switched({ previousAgentId,currentAgentId,agentName }).\n\n错误码体系(固定枚举,客户端可依赖):\n- invalid_agent_id,invalid_agent_id_format,agent_not_found,agent_busy,session_not_found.\n\n依赖拓扑:\n- 依赖: source/api/sse-server.ts(协议与连接),source/utils/session/sessionManager.ts(会话创建/续接),source/utils/MainAgentManager.ts(可用代理列表与配置查询).\n- 被依赖: 启动入口(命令/服务模式)调用 start/stop,以及 SSEServer 回调.\n\n避坑指南:\n- busy 判定必须覆盖所有进行中的任务: 对话生成流(sessionControllers) + pendingInteractions(等待 tool_confirmation/user_question).\n- session 绑定验证: 任何需要 sessionId 的操作必须通过 connectionSessionMap 校验连接已绑定,防止\"幽灵 session\"(客户端伪造 sessionId 或断线残留).\n- 回调职责清晰: sessionBoundHandler 回调内不得反向调用 SSEServer.bindSessionToConnection,避免循环与覆盖绑定;仅同步本地镜像.\n- 切换只影响后续新对话: 进行中的对话继续使用旧 agent 配置;若要立即生效,客户端应先 abort.\n- agent_list/agent_switched 为协议扩展,必须允许老客户端忽略未知事件类型(向后兼容).",
      "createdAt": "2026-02-13T18:37:30.800",
      "updatedAt": "2026-02-19T17:55:16.634"
    }
  ],
  "source/utils/MainAgentManager.ts": [
    {
      "id": "notebook-1770979050933_fpsuyvh74",
      "filePath": "source/utils/MainAgentManager.ts",
      "note": "职责: 主代理配置运行时管理器.负责加载内置+用户自定义主代理配置,维护当前主代理(currentAgentId)与运行时状态,并生成对话所需系统提示词与工具权限视图.\n本需求与 SSE 集成点:\n- 提供\"可用主代理列表\"(AgentInfo: id,name,description)给 SSEManager,用于 agent_list 与 error.availableAgents.\n- 提供按 agentId 获取配置的能力,让 SSE 会话级 agentId 能映射到一次对话执行所需的系统提示词+工具权限视图.\n不该做什么:\n- 不在本类内部持久化 SSE 会话级选择,会话级状态归 SSEManager/sessionManager.\n- 不将 SSE 协议对象耦合进此类(保持为纯业务管理器).\n接口摘要(本需求新增):\n- listAvailableAgents(): AgentInfo[].用于展示与选择,字段最小化(id,name,description),顺序需与 TUI 一致.\n- getAgentConfig(agentId): MainAgentConfig.为 SSEManager 切换与对话执行提供配置查询,未知 id 应给出清晰错误.\n- isValidAgentId(agentId): boolean.仅做\"是否存在于已加载配置\"的校验,不负责格式校验(格式规则由 SSE 层负责).\n依赖拓扑:\n- 依赖: source/utils/MainAgentConfigIO.ts(读取 main-agents.toml),source/config/mainAgents(内置配置).\n- 被依赖: TUI 模式下的快捷切换/执行层,以及 source/utils/sse/sseManager.ts.\n避坑指南:\n- AgentInfo 只用于展示/选择,不要把 mainAgentRole/tools 等敏感字段通过 SSE 下发.\n- 内置代理排序需稳定(BUILTIN_AGENT_ORDER),SSE 的 agent_list 顺序应与 TUI 保持一致,避免用户认知割裂.\n- 本类应在 initializeState 后才可被 list/get 调用;调用方(SSEManager)需在启动阶段确保初始化完成.",
      "createdAt": "2026-02-13T18:37:30.933",
      "updatedAt": "2026-02-13T19:58:14.552"
    }
  ],
  "source/utils/agentsPromptUtils.ts": [
    {
      "id": "notebook-1770694245812_aux171dlv",
      "filePath": "source/utils/agentsPromptUtils.ts",
      "note": "职责: 生成主代理和子代理的系统环境上下文信息,包括平台,shell,工作目录和时间信息.\n接口摘要: 无参数输入,输出包含系统环境信息的字符串.\n关键设计决策:\n- 时间戳只放置于系统环境信息中(北京时间,精确到分钟),不在每条工具返回和 user 消息中添加.\n依赖拓扑:\n- 被 MainAgentManager.ts,subAgentExecutor.ts 调用.\n避坑指南:\n- MUST 使用北京时间(UTC+8).\n- 本文件不应引入任何 UI 导航状态(showMcpPanel,mcpPanelSource)或 screen 逻辑.\n- 本文件也不应承担\"MCP 服务禁用\"或\"代理工具权限\"等配置逻辑,仅提供系统环境上下文.\n备注:\n- 与\"流式 API idle timeout/断开后丢弃\"无关.不得通过提示词或上下文注入来替代真实的 stream idle timeout 机制(必须由 api adapters + utils/core 代码层保障).",
      "createdAt": "2026-02-10T11:30:45.812",
      "updatedAt": "2026-02-13T11:53:45.193"
    }
  ],
  "sse-client/": [
    {
      "id": "notebook-1771515825742_q2ijvoqdm",
      "filePath": "sse-client/",
      "note": "职责: 正式 Web SSE 客户端子项目(PC + 手机协同),目录为 `sse-client/`.\n- Web UI(深色,移动优先)用于多服务端 Tab,会话,聊天,TODO,日志,Git 视图.\n- 本地 Node 控制 API(同源)用于启动/停止 Snow SSE 进程,以及执行项目级 Git 操作.\n\n技术栈决策(少依赖,可演进):\n- 主方案(推荐): TypeScript + 原生 DOM(ESM) + 轻量 store + Node.js http.\n  - 原因: 零重框架锁定,依赖最少,可逐步演进组件/状态层,长期维护成本最低.\n- 备选 A: TypeScript + 原生 DOM + esbuild 仅做 bundling(无框架).\n  - 适用: 需要单文件部署/减少模块请求数时.\n- 备选 B(不推荐,除非后续明确): Preact/React.\n  - 风险: 依赖与构建链膨胀,且会迫使引入更多生态(路由/状态/组件库).\n\n不该做什么:\n- 不替代 Snow CLI 核心(不改造对话执行/工具系统),仅作为可视化入口.\n- 不引入重前端框架/大型状态管理/组件库.\n- 不将认证扩展为对 Snow SSE 各业务端点的逐请求鉴权(仅 Web 入口门禁).\n\n接口摘要:\n- 输入:\n  - Snow SSE 服务端协议: `GET /events`(SSE),`POST /message`,`/session/*`.\n  - 控制面 API(同源): `/api/auth/*`,`/api/servers*`,`/api/git/*`.\n- 输出:\n  - 浏览器 UI + 对多个 Snow SSE 服务的连接与状态展示.\n\n依赖拓扑:\n- 依赖:\n  - Node.js runtime(仓库既有环境).\n  - Snow SSE 服务进程(snow --sse/--sse-daemon).\n  - git 可执行文件(用于 Git 视图能力).\n  - requirements/全平台网页版Snow SSE客户端需求.md(需求基线).\n- 被依赖: 无(独立子项目),但会被集成测试与文档引用.\n\n避坑指南:\n- 多服务端隔离: 任意可变状态必须以 serverId(tab) 分片,禁止共享 currentSessionId/yolo 等.\n- 协议向后兼容: unknown SSE event.type 必须静默忽略.\n- 控制面安全: 所有 workDir/filePath 必须严格校验,所有 child_process 必须用参数数组(execFile/spawn)防注入.\n- 进程与端口: 需要处理端口占用,孤儿进程,进程崩溃检测与列表自愈(刷新时重建状态).",
      "createdAt": "2026-02-19T23:43:45.742",
      "updatedAt": "2026-02-20T00:00:01.824"
    }
  ],
  "sse-client/src/server/": [
    {
      "id": "notebook-1771515825877_9cmsogs35",
      "filePath": "sse-client/src/server/",
      "note": "职责: 本地 Node 控制面(同源).负责:\n- 提供 /api/servers* 控制 API,启动/停止/列举多个 Snow SSE 进程(按 workDir 隔离).\n- 承载 Web 入口登录门禁(基于 ~/.snow/sse-config.json).\n- 对每个 workDir 提供 Git 基础能力 API(init,status,stage/unstage,diff,commit).\n- 静态资源托管: 为手机端提供同一 URL 访问的 Web UI.\n\n不该做什么:\n- 不实现 Snow SSE 的业务逻辑(聊天/会话/工具执行),不替代 Snow SSE 进程.\n- 不把认证扩展为对 Snow SSE 各业务端点的逐请求鉴权(仅 Web 入口门禁).\n\n接口摘要:\n- 输入: 浏览器 fetch 请求(同源,携带 session cookie),以及本机 child_process 执行 snow 与 git.\n- 输出: JSON 响应(统一 ApiResponse) + 静态资源.\n\n关键架构约束(本轮定稿,必须落实):\n1) Auth API 契约与返回口径固定:\n- POST /api/auth/login,/api/auth/logout,GET /api/auth/me.\n- 密码错误: HTTP 200 + success=false,errorCode=invalid_password,message=密码错误.\n- me 未登录: HTTP 200 + success=true,data:{isLoggedIn:false}.\n2) 登录态必须浏览器会话级:\n- 推荐使用 HttpOnly session cookie,且不设置 expires/max-age.\n- 禁止 localStorage 等跨会话持久化.\n- 浏览器会话结束后重新打开页面,me 必须返回 isLoggedIn=false.\n3) /api/servers/start 并发串行:\n- 后一个请求必须等待前一个完成后再扫描端口(关键区: 扫描+启动+落库).\n4) Git 口径:\n- status 修改区必须包含: 已修改未暂存 + 未跟踪 + 已删除未暂存.\n\n依赖拓扑:\n- 上游: sse-client/src/web/ 通过同源访问.\n- 下游: Node http/fs/path/os,child_process, Snow CLI 可执行文件(snow),git.\n\n避坑指南:\n- 进程管理: 必须记录 pid/port/workDir 映射,并处理崩溃/端口占用/重复启动.\n- 安全: 所有 workDir/filePath 必须严格校验,child_process 必须用参数数组(execFile/spawn),禁止 shell 拼接.\n- 认证会话存储: 禁止把 session token 写入磁盘(仅内存 Map + 可选 TTL).",
      "createdAt": "2026-02-19T23:43:45.877",
      "updatedAt": "2026-02-20T01:48:26.992"
    }
  ],
  "sse-client/src/server/http/": [
    {
      "id": "notebook-1771516217767_7wquqarsy",
      "filePath": "sse-client/src/server/http/",
      "note": "职责: sse-client 控制面 HTTP 服务内核.\n- 创建并启动本地 HTTP server(同源),托管静态 Web 资源,并将 /api/* 路由分发给 routes 层.\n- 提供最小中间件能力: JSON body 解析,错误捕获,统一响应封装(ApiResponse),CORS/缓存头(按需求),session/cookie.\n\n接口摘要:\n- 输入: Node http.IncomingMessage/ServerResponse.\n- 输出: 静态资源响应或 JSON(ApiResponse).\n\n推荐文件划分(便于长期维护):\n- server.ts/createServer.ts: create/start/stop.\n- router.ts: method+path 分发.\n- bodyParser.ts: 统一 JSON parse + size limit.\n- cookies.ts: cookie parse + set/clear session cookie(集中封装).\n- responses.ts: ok()/fail() 统一输出(ApiResponse).\n\n与本轮需求强相关的约束:\n- Auth 返回口径固定为 HTTP 200 + success 字段;HTTP 层不得擅自把 invalid_password 或未登录映射为 401/403.\n- 登录态必须浏览器会话级:\n  - 推荐使用 HttpOnly session cookie,且不设置 expires/max-age(浏览器关闭即失效).\n  - 禁止引导前端使用 localStorage 保存 token.\n\n依赖拓扑:\n- 上游: sse-client/src/web/ 同源访问.\n- 下游: routes/*,shared/contracts/*.\n\n避坑指南:\n- 安全: HTTP 层不可直接拼接命令行或路径,所有校验与执行在 routes/services.\n- JSON 解析必须有 size limit(建议 1MB)避免误操作导致内存膨胀.\n- cookie 解析与设置必须集中封装,避免各路由重复实现造成不一致(尤其是 Max-Age/Expires 的误设置).\n- 统一错误捕获必须覆盖同步与 Promise reject,避免未捕获异常导致控制面进程退出.",
      "createdAt": "2026-02-19T23:50:17.767",
      "updatedAt": "2026-02-20T01:50:02.264"
    }
  ],
  "sse-client/src/server/routes/": [
    {
      "id": "notebook-1771516217926_jl610bu9d",
      "filePath": "sse-client/src/server/routes/",
      "note": "职责: 控制面 API 路由层.定义 /api/* 端点,做请求参数校验与 DTO 映射,调用 services 层,并返回统一响应结构(ApiResponse).\n\n推荐文件划分(后续实现时按端点拆分):\n- authRoutes.ts: POST /api/auth/login,POST /api/auth/logout,GET /api/auth/me.\n- serversRoutes.ts: GET /api/servers,POST /api/servers/start,POST /api/servers/stop,POST /api/servers/stop-all.\n- gitRoutes.ts: /api/git/* (init,status,stage,unstage,diff,commit).\n- index.ts: 注册 routes 到 http router.\n\n接口摘要:\n- 输入: HTTP 请求(JSON body,cookie).\n- 输出: HTTP 200 JSON:\n  - 成功: { success:true,data? }.\n  - 失败: { success:false,errorCode,message }.\n\n关键契约(必须严格遵守):\n- Auth:\n  - 禁止使用 401/403 表达未登录与密码错误(需求固定为 HTTP 200 + success 标志).\n  - login 密码错误必须返回: success=false,errorCode=invalid_password,message=密码错误.\n  - me 未登录必须返回: success=true,data:{isLoggedIn:false}.\n- Servers:\n  - POST /api/servers/start 必须接入串行队列(实现层在 services),routes 不得并发触发端口扫描.\n- Git:\n  - status 修改区范围固定包含: modified-unstaged + untracked + deleted-unstaged.\n\n依赖拓扑:\n- 依赖: server/services/*,server/utils/*,shared/contracts/*,shared/errors.\n- 被依赖: server/http/*.\n\n避坑指南:\n- 参数校验必须覆盖: workDir 必须绝对路径且禁止路径穿越;port/timeoutMs 必须为合法整数范围;git filePath 必须是相对路径.\n- 错误映射必须统一: services 抛 DomainError -> routes 映射为 {success:false,errorCode,message}.\n- 安全: routes 层禁止拼接 shell 命令,所有执行都在 services 层且必须使用参数数组(execFile/spawn).",
      "createdAt": "2026-02-19T23:50:17.926",
      "updatedAt": "2026-02-20T01:51:44.347"
    }
  ],
  "sse-client/src/server/services/": [
    {
      "id": "notebook-1771516218068_iv4u5gk1l",
      "filePath": "sse-client/src/server/services/",
      "note": "职责: 控制面业务服务层(核心逻辑).\n- 进程管理: 启动/停止/枚举 Snow SSE 进程,维护 workDir <-> port <-> pid 的状态.\n- Git 服务: 在指定 workDir 执行安全的 git 命令(init,status,stage/unstage,diff,commit).\n- 认证服务: 读取 ~/.snow/sse-config.json 校验密码,并维护浏览器会话级登录态.\n\n推荐文件划分(后续实现时按职责拆分):\n- authService.ts: login/logout/me + session token 管理(只做 Web 门禁,不触碰 Snow SSE 端点).\n- serversService.ts: list/start/stop/stopAll + 端口扫描 + snow 进程 spawn.\n- gitService.ts: init/status/stage/unstage/diff/commit(严格相对路径校验).\n- index.ts: 仅导出 service 实例或 factory.\n\n接口摘要:\n- 输入: 结构化参数(workDir,port,timeoutMs,filePaths,message,password等).\n- 输出: 结构化结果或抛出领域错误(DomainError).\n\n必须落实的架构约束(本轮定稿):\n1) /api/servers/start 并发串行:\n- 必须在 services 层实现全局互斥/队列.\n- 关键区包含: 端口扫描 + 启动 + 写入运行中列表.\n- 后一个 start 必须等待前一个完成后再扫描端口.\n2) Auth 登录态(浏览器会话级):\n- 推荐: server 生成 session token,通过 HttpOnly session cookie 下发(不设置 expires/max-age).\n- server 侧会话存储: in-memory Map(token->metadata) + 可选 TTL 清理.\n- me 未登录返回 success=true + isLoggedIn=false(不抛错),login 密码错误返回 invalid_password.\n3) Git 修改区口径固定:\n- status 必须包含: modified-unstaged + untracked + deleted-unstaged.\n\n依赖拓扑:\n- 依赖: server/storage/*(servers 可持久化,auth sessions 建议仅内存),server/utils/*(校验/安全/child_process/队列),shared/errors.\n- 被依赖: server/routes/*.\n\n避坑指南:\n- 跨平台: Windows 路径与 shell 行为差异,必须使用 spawn/execFile 参数数组,避免拼接 shell.\n- 并发: 除 start 串行外,同一 workDir 的 git 操作也建议互斥,至少避免 git index.lock 冲突.\n- 可观测性: 日志中禁止输出 password,session token;错误 details 仅用于调试.",
      "createdAt": "2026-02-19T23:50:18.068",
      "updatedAt": "2026-02-20T01:51:44.191"
    }
  ],
  "sse-client/src/server/storage/": [
    {
      "id": "notebook-1771516218216_dnvsa7uw8",
      "filePath": "sse-client/src/server/storage/",
      "note": "职责: 控制面持久化与状态存储.\n\n建议拆分存储语义(避免与需求冲突):\n- servers 存储(可落盘): 保存运行中服务端列表(端口,pid,workDir,displayName,startedAt,lastSeen),用于页面刷新后恢复 UI.\n- auth sessions 存储(默认不落盘): 浏览器会话级登录态建议仅内存持有,由 session cookie 驱动,浏览器关闭即失效.\n\n推荐文件划分(后续实现时):\n- serversStore.ts: load/save/list/upsert/remove + 原子写.\n- authSessionsStore.ts: in-memory Map(token->metadata) + revoke/sweep.\n\n接口摘要:\n- 输入: servers/authSessions 等实体.\n- 输出:\n  - servers: JSON 文件(建议 ~/.snow/sse-web-client/servers.json).\n  - authSessions: in-memory.\n\n依赖拓扑:\n- 被依赖: server/services/*.\n\n避坑指南:\n- 原子写: 写文件必须使用临时文件 + rename.\n- schema 兼容: 新增字段必须可选并提供默认值.\n- 安全: 禁止把明文 password 或 session token 写入磁盘;错误 details 也不得包含敏感信息.",
      "createdAt": "2026-02-19T23:50:18.216",
      "updatedAt": "2026-02-20T01:51:44.485"
    }
  ],
  "sse-client/src/server/utils/": [
    {
      "id": "notebook-1771516218375_eeoe2ele6",
      "filePath": "sse-client/src/server/utils/",
      "note": "职责: 控制面通用工具.\n- 参数与路径校验(绝对路径,禁止路径穿越,相对文件路径白名单).\n- 端口扫描与占用检测.\n- child_process 调用封装(spawn/execFile),统一超时,stdout/stderr 截断.\n- 并发互斥/队列工具(供 services/start 串行化复用).\n\n推荐文件划分(后续实现时):\n- validatePaths.ts: validateWorkDir,validateRelativeFilePath.\n- portScanner.ts: findAvailablePort(basePort,maxAttempts,isPortFree).\n- processRunner.ts: execFileWithTimeout,spawnWithTimeout.\n- asyncMutex.ts: AsyncMutex/runExclusive.\n\n接口摘要:\n- 输入: 字符串/数字/命令参数.\n- 输出: 校验后的值或抛错.\n\n与本轮需求强相关的约束:\n- 端口扫描必须被串行队列保护,避免并发 start 互相抢端口.\n- workDir 必须绝对路径,且禁止 '..' 穿越;手机端输入 Windows 路径需兼容 'F:/...' 形式.\n\n依赖拓扑:\n- 被依赖: services/*(主要),routes/*(少量校验辅助).\n\n避坑指南:\n- 任何来自 web 的字符串都必须经过这里的校验,禁止在 service 内部临时拼 patch.\n- child_process 必须使用参数数组,禁止 shell:true.\n- Mutex/Queue 必须 try/finally release,否则会导致 start 永久阻塞.",
      "createdAt": "2026-02-19T23:50:18.375",
      "updatedAt": "2026-02-20T01:51:44.610"
    }
  ],
  "sse-client/src/shared/": [
    {
      "id": "notebook-1771515826135_hxgd7zhxi",
      "filePath": "sse-client/src/shared/",
      "note": "职责: sse-client 子项目内部共享的类型与协议定义(仅 TypeScript types).\n- 本地控制 API 的 request/response DTO(ApiResponse + auth/servers/git).\n- Web UI 与 server 侧共享的 errorCode 枚举与最小错误结构(DomainError).\n\n不该做什么:\n- 不依赖 Snow CLI 的 source/api 类型(避免跨包耦合与编译复杂度).\n- 不放运行时代码(纯 types/常量枚举).\n\n接口摘要:\n- 输入: requirements/全平台网页版Snow SSE客户端需求.md 的契约.\n- 输出: 稳定的 TS 类型,供 web/server 双端编译期约束.\n\n关键契约(本轮定稿):\n- Auth:\n  - login/logout/me 三端点固定.\n  - 字段名必须为 isLoggedIn(禁止 loggedIn 等替代).\n  - password 错误必须走 errorCode=invalid_password,且 HTTP 200.\n- Servers:\n  - start 字段名 workDir,port,timeoutMs.\n  - 并发 start 串行是实现约束,但 DTO 无需暴露锁状态.\n- Git:\n  - DiffViewer breakpoint 1200px 是 UI 契约,DTO 不承载.\n  - status 结果必须可表达 deleted-unstaged(已删除未暂存).\n\n依赖拓扑:\n- 被依赖: sse-client/src/server/*, sse-client/src/web/*.\n\n避坑指南:\n- 向后兼容: 新增字段必须可选.\n- errorCode 稳定性: 一旦发布不可随意更名;未知 code 前端兜底 message.\n- 禁止把 token/password 相关字段引入 contracts,避免误用与泄漏.",
      "createdAt": "2026-02-19T23:43:46.135",
      "updatedAt": "2026-02-20T01:48:27.282"
    }
  ],
  "sse-client/src/shared/contracts/": [
    {
      "id": "notebook-1771516264548_jm7lqob06",
      "filePath": "sse-client/src/shared/contracts/",
      "note": "补充: Git 协议建议.\n- 第一阶段建议 server API 直接返回 unified diff 文本,前端 DiffViewer 渐进增强.\n- 后续如需更强的 UI(行内评论/跳转),再升级为结构化 diff DTO(保持向后兼容,新增字段可选).",
      "createdAt": "2026-02-19T23:51:04.548",
      "updatedAt": "2026-02-19T23:51:04.548"
    },
    {
      "id": "notebook-1771516219540_xwornorap",
      "filePath": "sse-client/src/shared/contracts/",
      "note": "职责: sse-client 内部协议合同(contracts,TypeScript types).作为 web 与 server 双端的编译期约束,确保 API 契约与错误码稳定.\n\n接口摘要:\n- 输出: DTO types.\n  - Control API DTO: /api/auth/*,/api/servers*,/api/git/*.\n  - Snow SSE DTO: 仅抽取 Web 客户端实际消费的 SSEEvent/ClientMessage(unknown event.type 必须可被忽略).\n\n必须固化的 Control API 契约(与 requirements/全平台网页版Snow SSE客户端需求.md 一致):\n- Auth:\n  - POST /api/auth/login.\n    - 成功: HTTP 200 + { success:true }.\n    - 密码错误: HTTP 200 + { success:false,errorCode:'invalid_password',message:'密码错误' }.\n  - POST /api/auth/logout.\n    - 成功: HTTP 200 + { success:true }.\n  - GET /api/auth/me.\n    - 未登录: HTTP 200 + { success:true,data:{ isLoggedIn:false } }.\n    - 已登录: HTTP 200 + { success:true,data:{ isLoggedIn:true } }.\n  - 约束: 浏览器会话级登录态,禁止 localStorage 跨会话持久化.\n- Servers:\n  - GET /api/servers.\n  - POST /api/servers/start(字段: workDir,port,timeoutMs).\n  - POST /api/servers/stop,/api/servers/stop-all.\n  - 约束: start 并发请求必须串行处理(后一个等待前一个完成后再扫描端口).\n- Git(项目级,以 workDir 或 serverId 作为隔离边界):\n  - status 必须覆盖 3 类修改区: 已修改未暂存 + 未跟踪 + 已删除未暂存.\n  - diff 第一阶段建议返回 unified diff text;后续如需结构化 diff,必须保持向后兼容(新增字段可选).\n\n依赖拓扑:\n- 被依赖: sse-client/src/server/routes, sse-client/src/server/services, sse-client/src/web/services, sse-client/src/web/state.\n\n避坑指南:\n- 字段命名必须与需求一致(如 isLoggedIn,timeoutMs,workDir),不要使用 loggedIn 等替代名.\n- 向后兼容: DTO 新增字段必须可选,避免破坏旧页面/旧 server.\n- errorCode 稳定性: 一旦发布不可随意更名;客户端必须对未知 errorCode 做兜底展示.",
      "createdAt": "2026-02-19T23:50:19.540",
      "updatedAt": "2026-02-20T01:41:59.709"
    }
  ],
  "sse-client/src/shared/errors/": [
    {
      "id": "notebook-1771516219690_9qehcnsq2",
      "filePath": "sse-client/src/shared/errors/",
      "note": "职责: sse-client 内部错误码与错误对象规范.\n- 定义 Control API errorCode 枚举(servers/auth/git).\n- 定义统一的 DomainError(ApiError) 结构,用于 server/services 抛出并在 routes 层映射.\n\n接口摘要:\n- 输入: 原始错误.\n- 输出: 结构化错误({ errorCode,message,details? }).\n\n错误码分层(建议,保持稳定):\n- Auth:\n  - invalid_password.\n  - unauthorized(可选,仅用于内部,但本需求未使用 401,仍返回 HTTP 200).\n- Servers:\n  - invalid_work_dir,port_in_use,start_failed,stop_failed.\n  - start_in_progress(可选,当选择显式返回而非排队时使用;当前需求倾向排队串行,不强制需要).\n- Git:\n  - git_not_installed,repo_not_initialized,git_command_failed,invalid_file_path.\n\n文案与返回口径(需求固定):\n- login 密码错误必须返回 message=密码错误,且 HTTP 200.\n- me 未登录不应返回 errorCode,而是 success=true,data:{isLoggedIn:false}.\n\n依赖拓扑:\n- 被依赖: sse-client/src/server/services, sse-client/src/server/routes, sse-client/src/web/services.\n\n避坑指南:\n- errorCode 稳定性: 一旦发布不可随意更名,否则前端映射会失效.\n- details 仅用于调试,不得包含 password/session token.\n- 未知 errorCode: Web 端必须兜底展示 message,同时保留 errorCode 便于排查.",
      "createdAt": "2026-02-19T23:50:19.690",
      "updatedAt": "2026-02-20T01:42:55.430"
    }
  ],
  "sse-client/src/web/": [
    {
      "id": "notebook-1771516241433_9nd0jazox",
      "filePath": "sse-client/src/web/",
      "note": "职责补充(架构约束):\n- 采用\"渲染函数 + 小组件\"的模式,避免引入虚拟 DOM 框架.\n- 对复杂交互(会话管理弹窗,提问弹窗,Git diff)优先采用 view-model(纯数据)驱动渲染,减少直接 DOM 操作的分支.\n\n避坑指南补充:\n- 事件日志与 TODO: 只消费已收到的 SSE 事件,不新增后端日志查询 API(需求排除项).\n- unknown event.type: 必须在统一分发层忽略,不要在各视图重复写 switch.\n\n扩展点:\n- 未来若要引入微型模板/组件库,必须先证明其可被 tree-shake 且不引入运行时大依赖.",
      "createdAt": "2026-02-19T23:50:41.433",
      "updatedAt": "2026-02-19T23:50:41.433"
    },
    {
      "id": "notebook-1771515826002_se55c2j3t",
      "filePath": "sse-client/src/web/",
      "note": "职责: 浏览器端 UI 与状态管理(移动优先,深色).负责:\n- 多服务端 Tab 管理,每 Tab 独立的会话侧栏 + 主区(聊天视图/Git 视图平级切换).\n- SSE 通信: 每个服务端维护 EventSource 连接与事件分发,并通过 fetch 调用服务端 /message,/session/* 等 HTTP API.\n- 交互弹窗: 审批弹窗,提问弹窗(单选/多选/编辑某条选项/自定义输入/取消).\n- TODO 常驻区(可滚动)与当前会话事件日志弹窗(仅展示已收到 SSE 事件流).\n\n不该做什么:\n- 不引入重框架或复杂编译链;优先原生 DOM + TypeScript 模块.\n- 不假设 SSE 事件类型固定不变;必须对未知 event.type 容错忽略.\n\n关键架构约束(更新,必须落实):\n1) 登录态与门禁:\n- 登录态以 GET /api/auth/me 为唯一事实源.\n- 禁止 localStorage 持久化登录态.\n- 页面启动/刷新必须先调用 me: 未登录(isLoggedIn=false)则仅展示 LoginView.\n- login 密码错误是 HTTP 200 + success=false,errorCode=invalid_password,message=密码错误,必须走业务错误分支.\n2) 多服务端隔离:\n- 任意可变状态必须以 serverId(tab) 分片,禁止跨 Tab 共享 currentSessionId/currentAgentId 等.\n3) 连接控制区 UI 固化(验收口径,来自 requirements 2.5):\n- 禁止 serverSelect 下拉框,服务切换仅通过顶部 server tabs.\n- 禁止\"连接 SSE\"按钮,连接恢复统一使用\"重连\".\n- Tab 连接控制区仅允许\"重连\"+\"关闭\"两按钮;\"关闭\"必须关闭当前服务端(stopCurrentServer).\n- \"停止全部\"必须只出现在服务管理区,不得混入 Tab 连接控制区.\n4) Git DiffViewer 断点固定:\n- >=1200px 双列,<1200px 单列.\n\n接口摘要:\n- 输入: SSEEvent 流 + 本地控制 API + Snow SSE HTTP API.\n- 输出: DOM 渲染与用户操作,以及对控制 API/Snow SSE 的请求.\n\n依赖拓扑:\n- 依赖: sse-client/src/shared/ 类型; sse-client/src/server/ 提供的同源控制 API.\n- 参考: source/test/sse-client/(联调示例),requirements/全平台网页版Snow SSE客户端需求.md.\n\n避坑指南:\n- unknown SSE event.type 必须在统一分发层忽略,不要在各视图重复写 switch.\n- 日志弹窗禁止新增后端查询接口,仅使用已接收事件流(需求排除项).\n- 禁止为修 UI 快捷把 stopAll 绑定到 Tab 级按钮,否则会破坏隔离并造成误杀其他服务端.",
      "createdAt": "2026-02-19T23:43:46.002",
      "updatedAt": "2026-02-21T20:17:37.438"
    }
  ],
  "sse-client/src/web/components/": [
    {
      "id": "notebook-1771516218735_1j1aaows4",
      "filePath": "sse-client/src/web/components/",
      "note": "职责: 浏览器端可复用 UI 组件(无框架).\n- Tabs,Sidebar,Modal,Toast,Select,SplitPane(宽屏并排/窄屏堆叠),DiffViewer,TodoPanel,StatusBar.\n\n不该做什么:\n- 不直接访问全局 store(通过 props/回调注入).\n- 不内置业务含义(例如不假设一定是 Git 或 Chat,保持可复用).\n\n接口摘要:\n- 输入: props(纯数据) + callbacks.\n- 输出: DOM 元素与事件绑定.\n\n依赖拓扑:\n- 被依赖: views/*.\n\n避坑指南:\n- 控件必须可在移动端可用(触摸尺寸,滚动区域,固定高度).\n- DiffViewer 必须支持宽屏双列/窄屏单列自适应(与需求一致).",
      "createdAt": "2026-02-19T23:50:18.735",
      "updatedAt": "2026-02-19T23:50:18.735"
    }
  ],
  "sse-client/src/web/components/DiffViewer/": [
    {
      "id": "notebook-1771516264408_avgvj4tyx",
      "filePath": "sse-client/src/web/components/DiffViewer/",
      "note": "职责: Git diff 展示组件.\n\n接口摘要:\n- 输入: unified diff text(第一阶段)或结构化 diff(后续渐进增强,需向后兼容).\n- 输出: DOM(可滚动,可复制).\n\n核心布局规则(需求固定):\n- 视口宽度 >= 1200px: 双列对比.\n- 视口宽度 < 1200px: 单列展示.\n- 该 breakpoint 为产品契约,不做用户可配置.\n\n依赖拓扑:\n- 被依赖: web/views/GitView.\n\n避坑指南:\n- diff 文本可能很大,必须避免一次性 innerHTML 注入导致卡顿;优先分块渲染或按文件分页(性能优化可后置).\n- 禁止为了高亮引入重量级编辑器(如 Monaco);如需高亮,优先选择轻量方案或纯 CSS.",
      "createdAt": "2026-02-19T23:51:04.408",
      "updatedAt": "2026-02-20T01:42:00.427"
    }
  ],
  "sse-client/src/web/components/SplitPane/": [
    {
      "id": "notebook-1771516264243_inj0p1yop",
      "filePath": "sse-client/src/web/components/SplitPane/",
      "note": "职责: 响应式分栏组件.\n- 宽屏: 左右并排(聊天消息区与 TODO 区),比例可配置且支持拖拽(可选).\n- 窄屏: 自动切换为上下堆叠.\n\n不该做什么:\n- 不包含任何业务逻辑(仅布局).\n\n接口摘要:\n- 输入: child nodes + layout options(breakpoint,ratio).\n- 输出: 结构化 DOM + CSS class.\n\n依赖拓扑:\n- 被依赖: web/views/ChatView(聊天消息区 + TODO 区布局).\n\n避坑指南:\n- 断点策略必须与需求示意一致,且可通过 CSS variables 调整.\n- 避免监听 window resize 产生性能问题,优先 CSS media query.",
      "createdAt": "2026-02-19T23:51:04.243",
      "updatedAt": "2026-02-19T23:51:04.243"
    }
  ],
  "sse-client/src/web/services/": [
    {
      "id": "notebook-1771516219035_wrgm556z2",
      "filePath": "sse-client/src/web/services/",
      "note": "职责: 浏览器端通信层.\n- ControlApiClient: 调用同源控制 API(/api/auth/*,/api/servers*,/api/git/*).\n- SnowSseClient: 管理对单个 Snow SSE 服务端的连接(EventSource)与 HTTP 调用(/message,/session/*).\n\n推荐文件划分(后续实现时):\n- ControlApiClient.ts: 基于 fetch 的 DTO 调用,只处理 ApiResponse.\n- SnowSseClient.ts: EventSource 生命周期 + sendMessage/session API.\n- apiErrors.ts: 将网络错误/ApiResponse.errorCode 标准化为 UI 可展示错误.\n\n接口摘要:\n- 输入: baseUrl,request DTO.\n- 输出: Promise/事件回调,以及标准化错误.\n\n必须遵守的认证与状态约束:\n- 登录态以 GET /api/auth/me 为唯一事实源.\n- 禁止 localStorage 持久化登录态;页面刷新后必须重新调用 me.\n- 推荐服务端使用 HttpOnly session cookie,浏览器端 fetch 不需要手动保存 token(同源自动携带 cookie).\n\n依赖拓扑:\n- 依赖: shared/contracts,web/state.\n- 被依赖: web/views/*.\n\n避坑指南:\n- fetch 必须保证 cookie 会被携带(同源默认 same-origin;若配置 credentials,不能遗漏).\n- HTTP 200 但 success=false 属于业务错误,必须正常解析并交给 UI.\n- unknown SSE event.type 必须在统一分发层忽略.",
      "createdAt": "2026-02-19T23:50:19.035",
      "updatedAt": "2026-02-20T01:51:44.723"
    }
  ],
  "sse-client/src/web/state/": [
    {
      "id": "notebook-1771516218882_kiyeb3xax",
      "filePath": "sse-client/src/web/state/",
      "note": "职责: 浏览器端状态层(轻量 store).\n- 按 serverId 分片保存状态: 连接信息,SSE 事件流,会话列表,当前会话ID,YOLO 状态,profile/model,Git 状态.\n- 提供 actions/reducers 或 command-style API,保证状态更新可追踪.\n\n接口摘要:\n- 输入: action(payload),来自 web/services 的事件.\n- 输出: 新 state + subscribe 通知.\n\n新增必须固化的状态隔离与认证约束:\n- 登录态不持久化: store 中的 isLoggedIn 仅是 UI 当前态,刷新页面应通过 GET /api/auth/me 重建.\n- 禁止 localStorage 作为登录态来源.\n- serverId 分片是硬约束: 任何 currentSessionId,currentAgentId,yoloEnabled,gitStatus 等必须属于 serverId slice.\n\n依赖拓扑:\n- 依赖: shared/contracts 事件/DTO.\n- 被依赖: web/views/*.\n\n避坑指南:\n- 断线重连: connection close 时必须清理该 serverId 下的 session 绑定,agent 列表与 switching 状态,等待新 agent_list 恢复.\n- 未知 SSE event.type 必须忽略,且不得污染 store(避免存入无法渲染的数据).",
      "createdAt": "2026-02-19T23:50:18.882",
      "updatedAt": "2026-02-20T01:42:55.699"
    }
  ],
  "sse-client/src/web/styles/": [
    {
      "id": "notebook-1771516219213_85jvy09u6",
      "filePath": "sse-client/src/web/styles/",
      "note": "职责: 浏览器端样式与主题.\n- 深色主题为默认.\n- 响应式布局: 宽屏左右分栏(消息区 + TODO 并排,比例自适应),窄屏上下堆叠.\n- 统一 z-index 与 modal/backdrop 规则,避免弹窗覆盖错乱.\n\n不该做什么:\n- 不写与业务强绑定的选择器(尽量 class 化).\n\n接口摘要:\n- 输入: className.\n- 输出: UI 表现.\n\n依赖拓扑:\n- 被依赖: web/views,web/components.\n\n避坑指南:\n- 移动端滚动: 避免多层 scroll 互相抢夺,TODO 区滚动必须独立且可控.\n- Git 视图隐藏区域必须通过布局 class 一次性切换,避免散落多个 display:none 导致维护困难.",
      "createdAt": "2026-02-19T23:50:19.213",
      "updatedAt": "2026-02-19T23:50:19.213"
    }
  ],
  "sse-client/src/web/utils/": [
    {
      "id": "notebook-1771516219389_hv21id8am",
      "filePath": "sse-client/src/web/utils/",
      "note": "职责: 浏览器端通用工具.\n- 安全: escapeHtml,DOM helper.\n- 时间/格式化: formatBytes,formatTokens.\n- Diff 渲染辅助(若不引入第三方库).\n\n不该做什么:\n- 不包含业务状态.\n\n接口摘要:\n- 输入: string/number.\n- 输出: string/HTMLElement.\n\n依赖拓扑:\n- 被依赖: views/components/services.",
      "createdAt": "2026-02-19T23:50:19.389",
      "updatedAt": "2026-02-19T23:50:19.389"
    }
  ],
  "sse-client/src/web/views/": [
    {
      "id": "notebook-1771516218572_bohmwomzn",
      "filePath": "sse-client/src/web/views/",
      "note": "职责: 浏览器端页面级视图(无框架组件化).\n- ChatView: 会话栏 + 聊天区 + TODO + 状态栏(聊天视图下展示).\n- GitView: Git 主区(保留顶部 Tab 与左侧会话栏,隐藏聊天/TODO/日志/状态栏).\n- LoginView/ServerManagerModal/SessionManagerModal/Dialogs 等.\n\n推荐文件划分(后续实现时):\n- AppShell.ts: 顶部 Tab + 视图切换 + 左侧会话栏容器.\n- LoginView.ts: 登录表单 + 错误提示.\n- ChatView.ts/GitView.ts: 两个主视图.\n- modals/*: ServerManagerModal,SessionManagerModal,Dialogs.\n\n接口摘要:\n- 输入: state slice + view-model(纯数据) + 事件回调.\n- 输出: DOM 更新(render functions).\n\n与本轮需求强相关的 UI 规则:\n- 登录态: 页面启动先调用 GET /api/auth/me,未登录则只渲染 LoginView;禁止用 localStorage 绕过.\n- me 未登录属于正常分支(success=true,isLoggedIn=false),不可展示为错误 toast.\n- login 密码错误: HTTP 200 + success=false,errorCode=invalid_password,message=密码错误.\n- Git DiffViewer breakpoint 固定 1200px(>= 双列,< 单列).\n\n依赖拓扑:\n- 依赖: components/*,styles/*,state/*,services/*.\n\n避坑指南:\n- 视图切换口径必须严格按 requirements: Git 视图下隐藏聊天消息区,TODO 区,日志按钮与底部状态栏,但保留顶部 Tab 与左侧会话栏.\n- modal 打开时应锁定底层滚动与焦点.\n- 同一 UI 控件不得跨 serverId 读写状态,避免 Tab 串扰.",
      "createdAt": "2026-02-19T23:50:18.572",
      "updatedAt": "2026-02-20T01:51:44.853"
    }
  ],
  "sse-client/src/web/render.js": [
    {
      "id": "notebook-1771680138288_w3359bvgo",
      "filePath": "sse-client/src/web/render.js",
      "note": "⚠️ 实现要点补充(本轮需求: 点击左侧最近会话继续会话)\n\n渲染侧栏(session-list)时每个 item 有 data-session-id,目前 click handler 仅调用 actions.selectRecentSession(sessionId).该行为只更新 currentSessionId/选中态,不会请求 /session/load,因此不会真正\"继续会话\".\n\n建议(最小改动,保持分层):\n- render.js 点击 handler 改为调用 actions.loadSelectedSession(sessionId) (或先 selectRecentSession 再 loadSelectedSession,但需避免重复 render/双请求).\n- 为避免重复请求: 若 sessionId === state.chat.currentSessionId,可以只 selectRecentSession 或直接 return.\n\n注意事项:\n- 必须保持多服务端隔离: click handler 不应直接写 state,只能通过 actions,由 actions 内部使用 withServerTabContext(serverId) 写入对应 slice.\n- 历史消息过滤/摘要属于 sessions.js,render.js 不得做 tool/tool_calls 过滤(避免逻辑散落,也避免破坏实时 SSE 消息展示).\n- 事件绑定需防重复: renderApp 每次重新 innerHTML 后会重新绑定,因此 handler 内避免额外 render() 造成可见闪烁.",
      "createdAt": "2026-02-21T21:22:18.288",
      "updatedAt": "2026-02-21T21:22:18.288"
    },
    {
      "id": "notebook-1771676257168_wqpfaa3uf",
      "filePath": "sse-client/src/web/render.js",
      "note": "职责: Web 控制面(无框架)的核心渲染与 DOM 事件绑定层,把 state/view-model 渲染为页面 HTML,并在 render 后进行一次性事件绑定.\n\n边界(本阶段已固化,验收口径):\n- 服务端切换: 禁止使用下拉框(serverSelect).服务选择仅通过顶部 server tabs.\n- 连接控制区(Tab 连接控制): 每个 Tab 下只允许 2 个按钮:\n  1) 重连(reconnectBtn).\n  2) 关闭(closeServerBtn).\n- 禁止出现/绑定\"连接 SSE\"按钮(connectBtn).任何连接恢复动作统一走\"重连\"语义.\n- closeServerBtn 必须调用 stopCurrentServer(关闭当前 Tab 对应的服务端),不得误连 stopAll.\n- \"停止全部\"(stopAllServersBtn)属于服务管理区,不属于 Tab 连接控制区,避免验收歧义.\n\n新增契约(本轮需求: 点击最近会话继续会话):\n- 左侧\"最近5会话\"列表项点击,不得仅 selectRecentSession(sessionId),必须触发 loadSelectedSession(sessionId) 以真正\"继续该会话\"(拉历史消息并绑定会话).\n- 历史消息去噪/摘要逻辑必须在 sessions.js(loadSelectedSession) 内完成,render.js 只消费 state.chat.messages(最终展示数据),不承担协议解析.\n\n接口摘要:\n- 输入: state(包含 control.selectedServerId,control.actionLoading,connection.status 等).\n- 输出: 字符串 HTML + DOM 事件监听(调用 actions.*).\n\n依赖拓扑:\n- 依赖: web/state(actions,state shape),web/utils(escapeHtml,byId).\n- 被依赖: web/app.js(或入口)触发 render/rehydrate.\n\n避坑指南:\n- 事件绑定必须与 DOM id 完全一致,render 变更后需同步调整绑定,避免幽灵按钮/重复绑定.\n- 禁止把 stopAll 放进 Tab 区域(无论 UI 还是事件),否则会破坏多服务端隔离验收口径.\n- 最近会话 click handler 要防止重复触发两次 render 导致的重复请求: 建议 click handler 里只调用一次 loadSelectedSession,selectRecentSession 由 loadSelectedSession 成功后统一设置.",
      "createdAt": "2026-02-21T20:17:37.168",
      "updatedAt": "2026-02-21T21:21:06.014"
    }
  ],
  "sse-client/src/web/sessions.js": [
    {
      "id": "notebook-1771680023167_oigbzrqy6",
      "filePath": "sse-client/src/web/sessions.js",
      "note": "职责: Web 端会话管理动作层(无框架).聚焦于会话列表的拉取/分页/选择/继续/删除等流程,并负责把“会话选择”转化为 state.chat.currentSessionId 变更与历史消息加载.\n\n不该做什么:\n- 不处理 SSE 事件解析(由 web/sse.js 统一分发).\n- 不直接操作 DOM(除开 modal 的 hidden class),避免业务逻辑散落在 render.js.\n- 不跨 serverId 读写任何可变状态(必须使用 ensureServerTab/withServerTabContext).\n\n接口摘要:\n- createSessionActions({ render, getBaseUrl }) ->\n  - refreshSessionList(page?, serverId?): Promise<void>\n  - openSessionModal()/closeSessionModal()\n  - selectRecentSession(sessionId)\n  - prevSessionPage()/nextSessionPage()\n  - loadSelectedSession(sessionId): Promise<void>\n  - deleteSelectedSession(sessionId): Promise<void>\n\n依赖拓扑:\n- 依赖: web/state.js(ensureServerTab,setSessions,pushMessage,syncCurrentSessionEvents,clearSessionAttention,clearTodoUnread),以及 app.js 注入的 getBaseUrl.\n- 被依赖: web/app.js(actions 组装),web/render.js(事件绑定调用 actions.*).\n\n精简历史消息展示策略(契约,来自示例客户端与 TUI 经验):\n- loadSelectedSession() 将 /session/load 返回的 session.messages 转为 UI 展示消息时,必须执行“去噪/摘要”:\n  - 仅展示 role in ['system','user','assistant'] 的文本内容.\n  - role==='tool' 的 tool 结果消息默认隐藏.\n  - assistant.tool_calls 默认不展开参数,仅追加 system 摘要行: \"工具调用: <toolName>\".\n  - user.images/多模态内容用占位符显示(\"[包含图片]\")或拼接文本.\n- 上述策略必须做到确定性与向后兼容,即遇到未知字段要安全降级为 String(...).\n\n避坑指南:\n- 点击左侧最近会话只更新 currentSessionId 不足够.必须同时触发 loadSelectedSession(sessionId) 才能做到\"继续该会话\"(加载历史+绑定会话).\n- loadSelectedSession() 内部必须使用 withServerTabContext(serverId, ...) 包裹所有 state 写操作,避免 Tab 串会话.\n- refreshSessionList() 的 requestKey 防抖必须保留,避免慢请求覆盖新页.\n- 失败口径: 会话列表/加载失败不应阻断聊天主流程,仅 pushMessage('error',...) 并 render().",
      "createdAt": "2026-02-21T21:20:23.167",
      "updatedAt": "2026-02-21T21:20:23.167"
    }
  ],
  "sse-client/src/web/sse.js": [
    {
      "id": "notebook-1771680124830_riwy79zc9",
      "filePath": "sse-client/src/web/sse.js",
      "note": "职责: Web 端 Snow SSE 连接与事件分发层.负责对单个 serverTab 建立/关闭/重连 EventSource,并将 SSE event.type 分发到 state 更新,以及触发 dialogs/tips.\n\n不该做什么:\n- 不加载历史会话消息(/session/load),该职责归 sessions.js.\n- 不在此处实现 render.js 的 DOM 事件绑定.\n\n接口摘要:\n- createSseActions({ render, refreshSessionList }) ->\n  - connectSelectedServer(isReconnect?, serverId?)\n  - closeConnection(reason?, serverId?)\n  - reconnectNow()\n  - sendChat()\n  - openLogDetail(eventId)/closeLogDetail()\n\n关键架构约束:\n- unknown event.type 必须静默忽略(knownEventTypes 白名单).\n- 多服务端隔离: handleSseEvent(event, serverId) 与 withServerTabContext(serverId, ...) 必须贯穿所有状态写入.\n- tips 触发范围固定: 仅 tool_confirmation_request,user_question_request,complete 三类(并维持 allowCurrentSession 语义).\n- 会话维度事件: sessionScopedEventTypes 中的事件,若 event.data.sessionId 缺失,必须绑定到当前 state.chat.currentSessionId 以保证日志弹窗正确过滤.\n\n与本轮需求的边界:\n- sse.js 只负责实时 SSE message 事件 append 到 state.chat.messages(pushMessage).历史消息精简展示仅对 /session/load 返回的 session.messages 生效,必须在 sessions.js 完成,不要在此处对 pushMessage 做全局过滤(否则会误伤实时交互与错误提示).\n\n避坑指南:\n- Tab 切换后旧连接事件仍可能到达,必须确保 handleSseEvent 使用 serverId 参数正确写入对应 slice.\n- handleSseEvent('message') 当前将 event.data.content 渲染为 assistant,但服务端也会发 role:'user' 的 message.后续若要增强,应在 handleSseEvent 内统一根据 event.data.role 决定 pushMessage role,同时保持向后兼容.",
      "createdAt": "2026-02-21T21:22:04.830",
      "updatedAt": "2026-02-21T21:22:04.830"
    }
  ],
  "sse-client/src/web/state.js": [
    {
      "id": "notebook-1771680042939_1t1yyut6l",
      "filePath": "sse-client/src/web/state.js",
      "note": "职责: Web 端全局状态树与纯函数式状态更新工具(轻量 store,无框架).提供 serverId 分片的 Tab 状态隔离,以及 messages/events/todos/sessions/tips 等数据结构与写入 API.\n\n不该做什么:\n- 不在此处做任何 DOM 操作或网络请求.\n- 不在此处解析复杂协议或渲染 Markdown(保持 store 纯度).\n\n接口摘要:\n- state: { auth, control, chat, connection, git }.\n- serverTabs: state.control.serverTabs[serverId] -> { chat, connection, git }.\n- withServerTabContext(serverId, handler): 在指定 tab 上下文中执行读写,结束后恢复之前 tab.\n- pushMessage(role, content): 追加 UI 消息(当前仅支持 'system'|'assistant'|'user'|'error'),并保留最近 120 条.\n- pushEvent(event): 记录 SSE 事件并截断到 80 条,用于日志弹窗.\n- pushInfoMessage/getAllInfoMessages: tips 聚合(多 tab)与静默逻辑.\n\n消息展示与去噪约束(为配合历史消息精简展示):\n- state.chat.messages 是\"渲染层最终消费\"的数据结构,渲染层(render.js)不应再做协议级解析.\n- 历史会话消息从 API(session.load)转换为 state.chat.messages 时,应在 sessions.js 内完成过滤/摘要(如隐藏 role==='tool',把 assistant.tool_calls 变成 system 摘要行),而不是在 pushMessage 内做(避免影响实时 SSE message 展示).\n\n依赖拓扑:\n- 被依赖: web/render.js,web/sse.js,web/sessions.js,web/app.js.\n\n避坑指南:\n- 多服务端隔离硬约束: 任何对 state.chat/state.connection/state.git 的写入,若来源于非当前 selectedServerId,必须在 withServerTabContext(serverId, ...) 内进行.\n- resetChatForConnect() 会清空 sessionTouchedAt/sessionPager,意味着断线重连后会话排序依赖 /session/list 重建,不要在 render.js 做缓存.\n- pushInfoMessage 默认过滤当前会话 sessionId,仅在明确需要(如 complete 提示)时用 allowCurrentSession 绕过(该参数必须保持向后兼容).",
      "createdAt": "2026-02-21T21:20:42.939",
      "updatedAt": "2026-02-21T21:20:42.939"
    }
  ],
  "CurrentTaskPlan.md": [
    {
      "id": "notebook-1771735962484_dpvy47imp",
      "filePath": "CurrentTaskPlan.md",
      "note": "职责: 短线开发任务计划书.用于记录\"当前正在做的短期工作\"与可验收的执行步骤,不作为长期架构规范.\n\n使用规范:\n- 计划必须指向 requirements/* 的 SSoT 文档,自身不成为需求来源.\n- 计划项必须可验收(如 build 通过,或明确的行为检查点).\n- 当计划完成或不再相关时,应更新/清空文件内容并删除其 notebook 条目,避免将过程性信息长期留存为蓝图.\n\n避坑指南:\n- 不要在计划中固化可能漂移的实现细节(如具体变量名),优先写模块边界与验收口径.\n- 若涉及上游合并冲突,计划必须包含\"对齐点\"与\"禁止覆盖本地不可回退点\"清单.",
      "createdAt": "2026-02-22T12:52:42.484",
      "updatedAt": "2026-02-22T12:52:42.484"
    }
  ]
}