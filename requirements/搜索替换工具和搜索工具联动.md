# 需求文档

## 1. 项目现状与核心目标

当前 `filesystem-edit_search` 的 `searchContent` 主要由 LLM 生成,经常出现空格,换行,缩进,转义不一致,导致匹配失败或误匹配.

本需求目标是让 `ace-text_search` 与 `filesystem-edit_search` 联动,优先使用搜索结果引用来驱动替换,减少人工拼接 `searchContent` 带来的错误.

同时更新这两个工具的使用提示词,明确推荐联动使用,并精简原有过长注意事项.

## 2. 范围与边界

**功能点简述**:

- [ ] `ace-text_search` 返回结果支持被后续替换步骤引用(仅 `searchResultId`).返回的 `content` 必须是可直接用于 `filesystem-edit_search.searchContent` 的原文片段.
- [ ] `filesystem-edit_search` 联动输入参数仅保留 `searchResultId`.在联动模式下不要求用户手填 `searchContent`.
- [ ] 联动模式下,替换逻辑不走原有 fuzzy 搜索算法,避免 fuzzy 误匹配.
- [ ] 联动模式匹配失败时,沿用当前"匹配失败"处理逻辑,不额外新增过期结果专用流程.
- [ ] 两个工具的提示词改造为"推荐联动优先",并显著精简重复和冗长说明.

**排除项**:

- 不要求删除 `filesystem-edit_search` 现有传统模式(`searchContent + replaceContent`).
- 不要求本次新增跨会话持久化的搜索结果缓存.
- 不要求本次改造代码语法分析能力或引入额外代码理解模型.

## 3. 联动模式定义

### 3.1 目标流程

1. 先调用 `ace-text_search` 找到目标文本.
2. 用户或 LLM 确认具体命中项.
3. 调用 `filesystem-edit_search`,通过 `searchResultId` 引用命中项,或直接复用 `content` 到 `searchContent`,再输入替换内容.
4. 执行替换并返回结果.

### 3.2 联动模式关键约束

- 联动模式下,替换定位来源必须是被引用的搜索结果.
- 联动模式下,禁止回落到 fuzzy 匹配.
- 若引用结果无法匹配当前文件内容,按当前"匹配失败"逻辑返回失败.

### 3.3 兼容性要求

- 旧调用方式继续可用:
  - `searchContent + replaceContent` 仍可执行.
- 新调用方式优先推荐:
- `searchResultId + replaceContent`.

## 4. 两个工具的提示词改造要求

## 4.1 `ace-text_search` 提示词调整

**新增强调**:

- 本工具搜索结果可直接用于 `filesystem-edit_search` 联动替换.
- 当用户下一步目标是编辑文件时,优先建议走联动模式.

**精简方向**:

- 保留: 适合精确文本/正则检索的定位说明.
- 删除或缩短: 与联动无关的冗长示例堆叠.

## 4.2 `filesystem-edit_search` 提示词调整

**新增强调**:

- 推荐优先使用"先搜索后替换"联动模式.
- 联动模式下无需手工构造 `searchContent`.
- 联动模式下不启用 fuzzy 搜索,以避免误匹配.
- 新增联动工作流指导: 当确认要修改文件时,必须先新调用一次 `ace-text_search`,确认命中内容无误后,紧接着调用 `filesystem-edit_search` 并传入 `searchResultId` 进行修改.
- 强调"搜索结果要紧接消费": 搜索到待修改内容后立即执行替换,避免搜索结果过时.

**保留但收敛**:

- 保留传统模式说明,但降级为"兼容模式".
- 保留核心安全约束(完整代码块,上下文一致性等),避免误编辑.

**精简方向**:

- 将重复出现的路径/边界/示例说明合并成更短版本.
- 将"推荐流程"前置,减少用户先看到大量警告后不知如何操作的问题.

## 5. 输入输出示例(面向非专业人员)

### 例 1: 单文件联动替换成功

- 搜索输入:

```json
{
	"pattern": "ace-text_search",
	"isRegex": false,
	"fileGlob": "source/mcp/aceCodeSearch.ts"
}
```

- 搜索输出(示意):

```json
[
	{
		"searchResultId": "sr_001_regex",
		"filePath": "source/mcp/aceCodeSearch.ts",
		"line": 1551,
		"content": "name: 'ace-text_search'"
	}
]
```

- 替换输入(联动):

```json
{
	"filePath": "source/mcp/aceCodeSearch.ts",
	"searchResultId": "sr_001",
	"replaceContent": "name: 'ace-text-search'"
}
```

- 预期结果: 目标行被准确替换,返回 success.

### 例 2: 联动引用失败

- 替换输入使用了无效或已不匹配的引用:

```json
{
	"filePath": "source/mcp/aceCodeSearch.ts",
	"searchResultId": "sr_invalid",
	"replaceContent": "name: 'ace-text-search'"
}
```

- 预期结果: 按现有"匹配失败"逻辑返回失败,不回落 fuzzy.

### 例 3: 兼容模式(searchContent)继续可用

- 替换输入(传统模式):

```json
{
	"filePath": "source/mcp/aceCodeSearch.ts",
	"searchContent": "name: 'ace-text_search'",
	"replaceContent": "name: 'ace-text-search'"
}
```

- 预期结果: 行为与当前一致,用于兼容旧流程.

## 6. 验收标准

- [x] 文档内明确联动模式为推荐路径.(searchResultId 多行已测)
- [x] 文档内明确联动模式不走 fuzzy 搜索.(searchResultId 多行已测)
- [x] 文档内明确联动失败时沿用当前匹配失败逻辑.
- [x] 文档内包含可读的输入输出示例,覆盖成功与失败场景.
- [x] 文档内保留旧模式兼容说明,避免历史流程中断.

## 7. 新增需求补充(正则与多行可直接复用)

- `ace-text_search` 在正则搜索场景下,返回的每条命中 `content` 必须是可直接用于 `filesystem-edit_search.searchContent` 的原文片段.
- `ace-text_search` 在多行搜索场景下,返回的每条命中 `content` 必须严格等于实际匹配片段,匹配几行就返回几行,不拼接其他命中或文件前缀.
- 搜索结果为数组,每个元素代表一个独立命中,禁止将多条命中聚合到单个 `content` 字段.
- `content` 保持文件原始换行风格(`\n` 或 `\r\n`),调用方可直接透传为 `searchContent`.

### 例 4: 正则搜索后直接复用 content 进行替换

- 搜索输入(正则):

```json
{
	"pattern": "name:\\s*'ace-text_search'",
	"isRegex": true,
	"fileGlob": "source/mcp/aceCodeSearch.ts"
}
```

- 搜索输出(示意):

```json
[
	{
		"searchResultId": "sr_101",
		"filePath": "source/mcp/aceCodeSearch.ts",
		"line": 1551,
		"column": 3,
		"content": "name: 'ace-text_search'"
	}
]
```

- 替换输入(直接复用):

```json
{
	"filePath": "source/mcp/aceCodeSearch.ts",
	"searchContent": "name: 'ace-text_search'",
	"replaceContent": "name: 'ace-text-search'"
}
```

- 预期结果: 替换成功,无需人工再拼接搜索文本.

### 例 5: 多行搜索后直接复用 content 进行替换

- 搜索输入(多行 literal):

```json
{
	"pattern": "lineA\nlineB",
	"isRegex": false,
	"fileGlob": "source/**/*.ts"
}
```

- 搜索输出(示意):

```json
[
	{
		"searchResultId": "sr_201",
		"filePath": "source/sample.ts",
		"line": 20,
		"column": 1,
		"content": "lineA\nlineB"
	}
]
```

- 替换输入(直接复用):

```json
{
	"filePath": "source/sample.ts",
	"searchContent": "lineA\nlineB",
	"replaceContent": "lineA\nlineB_updated"
}
```

- 预期结果: 多行片段被准确替换,不依赖 fuzzy.

### 例 6: 多结果返回格式(禁止聚合)

- 搜索输出(示意):

```json
[
	{
		"searchResultId": "sr_301",
		"filePath": "a.ts",
		"line": 10,
		"column": 5,
		"content": "targetA"
	},
	{
		"searchResultId": "sr_302",
		"filePath": "a.ts",
		"line": 30,
		"column": 2,
		"content": "targetB"
	}
]
```

- 预期结果: 每条命中独立返回,调用方可任选一条 `content` 直接作为 `searchContent`.
--------------------------------
已完成