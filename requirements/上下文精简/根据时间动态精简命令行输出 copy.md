<!-- # 需求文档：动态精简命令行工具返回内容

## 1. 项目现状与核心目标

### 1.1 项目现状

- 项目中命令行工具（terminal-execute）的返回结果包含时间戳（timestamp 字段，毫秒级数字）
- 工具返回结果通过 conversationMessages 数组传递给 AI API
- 命令执行结果可能包含大量输出（如构建日志、测试结果等），占用大量上下文

### 1.2 核心目标

动态精简会话上下文中的命令行工具返回内容，实现：

- 减少老旧命令输出对上下文的占用
- 保留关键的错误信息，避免 Agent 重复犯错
- 保留最近的重要执行结果
- 如需详情，Agent 可重新执行命令

**重要原则**：

- ⭐ **只精简发送给 API 的上下文**：不影响会话持久化存储
- ⭐ **会话文件完整记录**：本地会话文件如实保存所有原始内容，不做任何精简
- ⭐ **精简是临时的**：每次发送给 API 前动态计算精简，不修改历史数据

---

## 2. 范围与边界

### 2.1 功能点

**精简触发条件**（同时满足）：

- [ ] 内容来自命令行工具（terminal-execute）
- [ ] 返回时间超过当前时间 15 分钟
- [ ] 不是最近 5 个工具调用返回内容之一
- [ ] 命令执行成功（非错误返回）

**精简方式**：

- [ ] 将原始返回内容替换为单行占位符：`此命令返回内容已过时`

**保留策略**：

- [ ] **保留最近 5 个工具调用返回内容**：无论时间多久，最近 5 个工具（所有类型）的返回内容完整保留
- [ ] **保留所有错误返回**：命令执行失败或返回错误信息时，完整保留原始内容
- [ ] **保留 15 分钟内的结果**：未超过时间阈值的结果完整保留

### 2.2 排除项

- [ ] 不精简其他类型工具的返回内容（filesystem-read, filesystem-edit, ace-tools 等）
- [ ] 不修改存储的历史消息，仅在发送给 API 前临时精简
- [ ] 不影响命令的重新执行能力
- [ ] ⭐ **精简只影响发送给 API 的上下文**：会话持久化文件如实保存所有原始内容
- [ ] ⭐ **精简操作是临时的**：不修改 conversationMessages 数组中的原始数据，只创建精简后的副本发送给 API

### 2.3 适用场景

**场景 1：正常对话流程**

- 用户发送消息 → 构建上下文 → 精简 → 发送给 API

**场景 2：恢复会话流程**

- 从本地恢复历史会话 → 构建上下文 → 精简 → 发送给 API
- 重要：即使历史消息完整保存，恢复后发送给 API 时也应动态精简

---

## 3. 举例覆盖需求和边缘情况

### 3.1 基础示例

**例 1：超过 15 分钟的成功命令，非最近 5 个**

```
工具调用时间：2026-01-31 01:00:00
当前时间：2026-01-31 01:20:00（超过 15 分钟）
工具返回内容：
{
  "stdout": "Building project...\nDone in 3.2s",
  "stderr": "",
  "exitCode": 0
}
最近 5 个工具返回：[其他 5 个更新的工具结果]

【精简后】
{
  "content": "此命令返回内容已过时",
  "timestamp": 1738287600000,
  "role": "tool"
}
```

**例 2：超过 15 分钟的成功命令，但在最近 5 个中**

```
工具调用时间：2026-01-31 01:00:00
当前时间：2026-01-31 01:20:00（超过 15 分钟）
工具返回内容：
{
  "stdout": "Building project...\nDone in 3.2s",
  "stderr": "",
  "exitCode": 0
}
最近 5 个工具返回：[包含此命令]

【精简后】
✅ 完整保留，不精简
```

**例 3：超过 15 分钟的错误命令**

```
工具调用时间：2026-01-31 01:00:00
当前时间：2026-01-31 01:20:00（超过 15 分钟）
工具返回内容：
{
  "stdout": "",
  "stderr": "Error: Cannot find module 'xxx'",
  "exitCode": 1
}
最近 5 个工具返回：[其他 5 个更新的工具结果]

【精简后】
✅ 完整保留，不精简（因为是错误返回）
```

**例 4：未超过 15 分钟的成功命令**

```
工具调用时间：2026-01-31 01:30:00
当前时间：2026-01-31 01:35:00（未超过 15 分钟）
工具返回内容：
{
  "stdout": "Building project...\nDone in 3.2s",
  "stderr": "",
  "exitCode": 0
}
最近 5 个工具返回：[其他 4 个工具结果]

【精简后】
✅ 完整保留，不精简（未超时）
```

### 3.2 边缘情况

**例 5：混合场景 - 多个命令按时间排序**

```
当前时间：2026-01-31 02:00:00

工具返回列表（按时间倒序）：
1. [01:55:00] filesystem-read 成功 → 保留（最近 5 个内）
2. [01:50:00] terminal-execute 成功 → 保留（最近 5 个内）
3. [01:45:00] terminal-execute 成功 → 保留（最近 5 个内）
4. [01:40:00] terminal-execute 错误 → 保留（错误返回）
5. [01:35:00] terminal-execute 成功 → 保留（最近 5 个内）
6. [01:30:00] terminal-execute 成功 → 保留（最近 5 个内）
7. [01:20:00] terminal-execute 成功 → 精简（超时 + 非最近 5 个 + 非错误）
8. [00:50:00] terminal-execute 成功 → 精简（超时 + 非最近 5 个 + 非错误）
9. [00:40:00] filesystem-read 成功 → 保留（非 terminal-execute）
10. [00:30:00] terminal-execute 错误 → 保留（错误返回）

【精简结果】
- 索引 7, 8 被精简为 "此命令返回内容已过时"
- 其他所有结果完整保留
```

**例 6：非命令行工具不受影响**

```
工具调用时间：2026-01-31 00:30:00
当前时间：2026-01-31 01:00:00（超过 15 分钟）
工具类型：filesystem-read
工具返回内容：
[大量文件内容...]

【精简后】
✅ 完整保留，不精简（非 terminal-execute）
```

**例 7：边界时间判断**

```
工具调用时间：2026-01-31 00:44:59.999
当前时间：2026-01-31 01:00:00.000
时间差：15 分 0.001 秒（刚好超过 15 分钟）

【精简后】
⚠️ 精简（严格判断：> 15 * 60 * 1000 毫秒）
```

**例 8：边界时间判断（未超时）**

```
工具调用时间：2026-01-31 00:45:00.000
当前时间：2026-01-31 01:00:00.000
时间差：15 分 0 秒（刚好等于 15 分钟）

【精简后】
✅ 保留（严格判断：<= 15 * 60 * 1000 毫秒）
```

**例 9：精简不影响持久化存储**

```
场景：命令执行成功，超过 15 分钟，非最近 5 个

工具调用时间：2026-01-31 01:00:00
当前时间：2026-01-31 01:20:00（超过 15 分钟）
工具返回内容：
{
  "stdout": "Building project...\nDone in 3.2s",
  "stderr": "",
  "exitCode": 0
}

【发送给 API 的上下文】
{
  "content": "此命令返回内容已过时",
  "timestamp": 1738287600000,
  "role": "tool"
}

【会话持久化文件中的记录】
{
  "content": "{\"stdout\":\"Building project...\\nDone in 3.2s\",\"stderr\":\"\",\"exitCode\":0}",
  "timestamp": 1738287600000,
  "role": "tool"
}

关键说明：
- ✅ 发送给 API 时内容被精简
- ✅ 本地会话文件保存完整原始内容
- ✅ 恢复会话后再次发送给 API 时，依然会精简
```

### 3.3 识别命令行工具返回内容

**识别方式**：检查 content 是否包含命令执行结果的特征字段

```
包含以下任一特征即为命令行工具返回：
- "stdout":
- "stderr":
- "exitCode":
```

**示例判断**：

```json
// ✅ 是命令行工具返回
{
  "content": "{\"stdout\":\"hello\",\"stderr\":\"\",\"exitCode\":0}"
}

// ✅ 是命令行工具返回（部分字段）
{
  "content": "{\"stdout\":\"Build completed\"}"
}

// ❌ 不是命令行工具返回
{
  "content": "File content: ..."
}

// ❌ 不是命令行工具返回
{
  "content": "{\"path\":\"/path/to/file\"}"
}
```

### 3.4 错误识别

**识别方式**：检查以下任一条件

```
满足以下任一条件即为错误返回：
- content 以 "Error:" 开头
- messageStatus === 'error'
- stderr 非空（对于命令行工具）
```

**示例**：

```json
// ✅ 是错误返回（content 以 Error: 开头）
{
  "content": "Error: Command failed with exit code 1"
}

// ✅ 是错误返回（messageStatus === 'error'）
{
  "content": "...",
  "messageStatus": "error"
}

// ✅ 是错误返回（stderr 非空）
{
  "content": "{\"stdout\":\"\",\"stderr\":\"Connection refused\",\"exitCode\":1}"
}
```

---

## 4. 实现位置建议

**文件**：`source/hooks/conversation/utils/messageCleanup.ts`
**时机**：在 `cleanOrphanedToolCalls` 之后执行
**影响范围**：仅影响发送给 API 的消息，不修改存储的历史消息

```typescript
// 在 useConversation.ts 中的调用位置
cleanOrphanedToolCalls(conversationMessages);
simplifyOutdatedTerminalResults(conversationMessages); // 新增
```

---

## 5. 实现伪代码逻辑

```
函数 simplifyOutdatedTerminalResults(messages):
    当前时间 = Date.now()
    超时阈值 = 15 * 60 * 1000  // 15分钟（毫秒）
    保留最近数量 = 5

    // 步骤1：收集所有工具返回消息（按时间倒序）
    所有工具返回 = []
    对于 每个 message 在 messages 中（按索引顺序）:
        如果 message.role === 'tool' 且 message.timestamp 存在:
            所有工具返回.添加({
                索引: message.索引,
                时间戳: message.timestamp,
                是否错误: 判断是否错误(message),
                是否命令行工具: 判断是否命令行工具(message)
            })

    // 步骤2：按时间戳倒序排序（最新的在前）
    所有工具返回.排序((a, b) => b.时间戳 - a.时间戳)

    // 步骤3：标记需要精简的消息
    需要精简的索引 = []
    对于 每个 result 在 所有工具返回 中（从第6个开始）:
        如果 result.索引 < 保留最近数量:  // 在最近5个内
            继续
        如果 result.是否错误:  // 错误返回
            继续
        如果 不是 result.是否命令行工具:  // 非命令行工具
            继续
        如果 (当前时间 - result.时间戳) > 超时阈值:  // 超过15分钟
            需要精简的索引.添加(result.索引)

    // 步骤4：执行精简
    对于 每个 索引 在 需要精简的索引 中:
        messages[索引].content = "此命令返回内容已过时"

    // 步骤5：日志记录（可选）
    如果 需要精简的索引.长度 > 0:
        输出日志：精简了 X 个过时命令返回内容

函数 判断是否命令行工具(message):
    content = message.content
    如果 content 为空:
        返回 false
    // 检查是否包含命令执行结果的特征字段
    返回 content.包含('"stdout":') 或
         content.包含('"stderr":') 或
         content.包含('"exitCode":')

函数 判断是否错误(message):
    // 方法1：检查 content 前缀
    如果 message.content.以("Error:") 开头:
        返回 true

    // 方法2：检查 messageStatus
    如果 message.messageStatus === 'error':
        返回 true

    // 方法3：检查命令行工具的 stderr
    如果 判断是否命令行工具(message):
        尝试:
            result = JSON.解析(message.content)
            如果 result.stderr 非空 且 result.stderr.长度 > 0:
                返回 true
        捕获:
            pass

    返回 false
```

---

## 6. 验收标准

- [ ] 超过 15 分钟的成功命令行返回被精简为 "此命令返回内容已过时"
- [ ] 最近 5 个工具调用返回内容始终完整保留（无论时间多久）
- [ ] 所有错误返回完整保留（不精简）
- [ ] 其他类型工具返回不受影响
- [ ] 存储的历史消息未被修改
- [ ] 边界时间判断准确（15 分钟整保留，超过则精简）
- [ ] 添加了日志输出，便于调试和监控

---

## 7. 后续优化建议

- [ ] 考虑将精简阈值（15 分钟）和保留数量（5 个）设为可配置参数
- [ ] 监控精简效果，统计上下文节省的 token 数量
- [ ] 根据实际使用情况调整时间阈值和保留数量 -->
已完成