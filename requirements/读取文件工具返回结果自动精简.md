<!-- # 需求文档:filesystem-read 工具返回结果自动精简

## 1. 项目现状与核心目标

### 1.1 项目现状

- 项目中 `filesystem-read` 工具可以读取文件内容,支持完整读取或部分读取(指定行号范围)
- 工具返回结果包含带行号的文件内容、符号信息和笔记本条目
- 频繁读取同一文件会占用大量上下文空间(如反复读取同一个大文件的不同部分)
- 项目已实现了 `terminal-execute` 工具的历史精简机制(参考"根据时间动态精简命令行输出.md")
- 但 `filesystem-read` 工具目前没有类似的历史精简机制

### 1.2 核心目标

动态精简会话上下文中的 `filesystem-read` 工具返回内容,实现:

- 减少同一文件的重复读取内容对上下文的占用
- 保留每个文件最新的读取结果,确保 AI 获取最新信息
- 保留错误读取信息,避免 Agent 重复犯错
- 如需历史读取内容,Agent 可重新读取文件

**重要原则**:

- ⭐ **只精简发送给 API 的上下文**: 不影响会话持久化存储
- ⭐ **会话文件完整记录**: 本地会话文件如实保存所有原始内容,不做任何精简
- ⭐ **精简是临时的**: 每次发送给 API 前动态计算精简,不修改历史数据
- ⭐ **按文件分组统计**: 每个文件独立计算保留最新的 5 次读取

---

## 2. 范围与边界

### 2.1 功能点

**精简触发条件**(同时满足):

- [ ] 内容来自 `filesystem-read` 工具
- [ ] 对同一文件的读取次数超过 5 次
- [ ] 该次读取不是该文件最新的 5 次读取之一
- [ ] 读取成功(非错误返回)

**精简方式**:

- [ ] 将原始返回内容替换为单行占位符: `[该文件的历史读取内容已压缩,请参看最新读取结果]`

**保留策略**:

- [ ] **每个文件保留最新的 5 次读取**: 无论读取次数多少,每个文件最新的 5 次读取完整保留
- [ ] **保留所有错误读取**: 文件读取失败时,完整保留原始错误信息
- [ ] **未超过 5 次的文件**: 如果文件读取次数 <= 5 次,不进行精简

### 2.2 排除项

- [ ] 不精简其他类型工具的返回内容(terminal-execute, filesystem-edit, ace-tools 等)
- [ ] 不修改存储的历史消息,仅在发送给 API 前临时精简
- [ ] 不影响文件的重新读取能力
- [ ] ⭐ **精简只影响发送给 API 的上下文**: 会话持久化文件如实保存所有原始内容
- [ ] ⭐ **精简操作是临时的**: 不修改 conversationMessages 数组中的原始数据,只创建精简后的副本发送给 API

### 2.3 文件识别方式

**从工具调用参数中提取文件路径**:

- 通过 `message.tool_calls` 数组找到对应的工具调用
- 从 `tool_call.function.arguments` 中解析 `filePath` 参数
- 支持单文件路径和文件路径数组

**识别失败时的处理**:

- 如果无法提取文件路径(如老会话缺少 tool_calls 信息),则不精简该记录
- 如果文件路径为空或无效,则不精简该记录

### 2.4 适用场景

**场景 1: 正常对话流程**

- 用户发送消息 → 构建上下文 → 精简 → 发送给 API
- 每次工具调用后都会重新构建上下文并精简

**场景 2: 恢复会话流程**

会话恢复有多种触发方式,所有方式最终都通过同一个位置构建 API 上下文并精简:

- **方式 1: /resume 命令恢复最新会话**

  - 通过 `sessionManager.loadSession()` 从磁盘加载会话
  - 会话消息包含完整的原始历史数据
  - 下次发送 API 时自动精简

- **方式 2: 从会话面板选择历史会话**

  - 用户在会话列表中选择某个历史会话
  - 加载该会话的完整历史消息
  - 下次发送 API 时自动精简

- **方式 3: 上下文压缩后加载压缩会话**
  - 手动触发上下文压缩后加载压缩后的会话
  - 压缩会话保留精简后的消息
  - 下次发送 API 时仍然会重新精简

**关键点**: 所有恢复场景最终都通过 `useConversation.ts` 中的同一个位置构建 API 消息,精简操作在发送前自动执行,无需在恢复逻辑中单独调用。

**场景 3: 双击 ESC 回退会话**

- 用户双击 ESC 打开历史菜单
- 选择某个历史时间点进行回退
- 回退操作截断 `session.messages`(删除选定时间点之后的所有消息)
- 回退后的消息在下次发送 API 时自动精简

**场景 4: 上下文压缩流程**

- 当 token 使用率超过阈值时触发自动压缩
- 通过 AI 模型生成历史对话摘要
- 压缩后的消息保存为新会话
- 压缩会话在恢复和发送时仍会应用文件读取历史精简

**统一入口: 所有场景的精简位置**

```
source/hooks/conversation/useConversation.ts (行 339-347)

while (true) {
  const apiMessages = [...conversationMessages];  // 复制原始消息
  cleanOrphanedToolCalls(apiMessages);           // 清理孤立的tool_calls
  simplifyOutdatedTerminalResults(apiMessages);  // 精简过时命令行结果
  simplifyHistoricalFileReads(apiMessages);      // 精简文件读取历史 ← 新增

  // 发送给API...
}
```

**为什么只需在一处调用**:

1. **唯一入口**: 所有 API 调用都通过这个 while 循环构建 `apiMessages`
2. **动态精简**: 每次发送前都重新精简,确保最新状态
3. **自动覆盖**:
   - 正常对话 → 新消息添加到 conversationMessages → 下次迭代精简
   - 恢复会话 → conversationMessages 被替换为历史消息 → 下次迭代精简
   - 回退会话 → conversationMessages 被截断 → 下次迭代精简
4. **不影响存储**: 精简只影响 `apiMessages` 副本,不修改 `conversationMessages` 或 `session.messages`

**示例: 会话恢复后的精简流程**

```
1. 用户选择恢复某个历史会话
2. sessionManager.loadSession() 从磁盘加载完整历史
3. conversationMessages = session.messages (包含7次文件读取记录)
4. 用户发送新消息
5. 进入while循环:
   apiMessages = [...conversationMessages]  // 复制7次记录
   simplifyHistoricalFileReads(apiMessages) // 精简为最新5次
6. 发送精简后的apiMessages给API
7. conversationMessages保持不变(仍有7次完整记录)
```

---

## 3. 举例覆盖需求和边缘情况

### 3.1 基础示例

**例 1: 同一文件读取超过 5 次**

```
文件: src/components/Button.tsx
读取次数: 7 次

读取记录(按时间倒序):
1. [2026-01-31 02:50:00] 读取行 1-50 → 保留(最新 5 次内)
2. [2026-01-31 02:45:00] 读取行 51-100 → 保留(最新 5 次内)
3. [2026-01-31 02:40:00] 读取行 1-100 → 保留(最新 5 次内)
4. [2026-01-31 02:35:00] 读取行 200-250 → 保留(最新 5 次内)
5. [2026-01-31 02:30:00] 读取行 1-50 → 保留(最新 5 次内)
6. [2026-01-31 02:25:00] 读取行 100-150 → ⚠️ 精简为占位符
7. [2026-01-31 02:20:00] 读取行 150-200 → ⚠️ 精简为占位符

【精简后结果】
- 索引 1-5: 完整保留
- 索引 6: content = "[该文件的历史读取内容已压缩,请参看最新读取结果]"
- 索引 7: content = "[该文件的历史读取内容已压缩,请参看最新读取结果]"
```

**例 2: 同一文件读取未超过 5 次**

```
文件: src/utils/helpers.ts
读取次数: 3 次

读取记录(按时间倒序):
1. [2026-01-31 02:50:00] 读取行 1-100 → 保留(未超过 5 次)
2. [2026-01-31 02:45:00] 读取行 50-150 → 保留(未超过 5 次)
3. [2026-01-31 02:40:00] 读取行 1-50 → 保留(未超过 5 次)

【精简后结果】
✅ 全部保留,不精简
```

**例 3: 包含错误读取**

```
文件: src/config/settings.json
读取次数: 7 次(其中 1 次失败)

读取记录(按时间倒序):
1. [02:50:00] 读取行 1-50 → 保留(最新 5 次内)
2. [02:45:00] 读取行 51-100 → 保留(最新 5 次内)
3. [02:40:00] Error: File not found → ✅ 保留(错误读取,不计入限制)
4. [02:35:00] 读取行 1-100 → 保留(最新 5 次内)
5. [02:30:00] 读取行 200-250 → 保留(最新 5 次内)
6. [02:25:00] 读取行 1-50 → 保留(最新 5 次内)
7. [02:20:00] 读取行 100-150 → ⚠️ 精简为占位符

【精简后结果】
- 索引 1-6: 完整保留(包括错误读取)
- 索引 7: content = "[该文件的历史读取内容已压缩,请参看最新读取结果]"

说明: 错误读取不计入 5 次限制,始终保留
```

**例 4: 多文件混合场景**

```
会话中读取了 3 个文件:

文件 A: src/App.tsx (读取 3 次)
文件 B: src/components/Button.tsx (读取 7 次)
文件 C: src/utils/api.ts (读取 2 次)

【精简结果】
- 文件 A: 全部保留(未超过 5 次)
- 文件 B: 保留最新 5 次,精简 2 次旧读取
- 文件 C: 全部保留(未超过 5 次)
- terminal-execute 结果: 不受影响(其他工具)
```

### 3.2 边缘情况

**例 5: 批量读取多个文件**

```
一次调用读取多个文件:
filesystem-read(filePath=["file1.ts", "file2.ts", "file3.ts"])

【处理方式】
选项A: 将每个文件视为一次独立读取
- file1.ts 的读取次数 +1
- file2.ts 的读取次数 +1
- file3.ts 的读取次数 +1

推荐使用选项A,便于按文件独立统计
```

**例 6: 文件路径规范化**

```
同一文件的不同路径表示:
- "src/components/Button.tsx"
- "./src/components/Button.tsx"
- "F:/Projects/snow-cli/src/components/Button.tsx"

【处理方式】
⚠️ 需要路径规范化处理
- 统一转换为相对路径(相对于项目根目录)
- 移除 "./" 前缀
- 规范化路径分隔符

推荐使用 `path.relative()` 和 `path.normalize()` 进行规范化
```

**例 7: 目录读取**

```
读取目录(返回文件列表):
filesystem-read(filePath="src/components/")

【处理方式】
- 目录读取也计入该路径的读取次数
- 与文件读取同等对待
- 超过 5 次后精简旧记录
```

**例 8: 无法提取文件路径**

```
场景: 老会话中缺少 tool_calls 信息

【处理方式】
✅ 不精简该记录,完整保留原始内容
原因: 无法确定是哪个文件的读取,无法统计
```

**例 9: 文件路径为空或无效**

```
工具调用参数:
{
  "filePath": ""
}
或
{
  "filePath": null
}

【处理方式】
✅ 不精简该记录,完整保留原始内容
原因: 无法识别文件,无法统计
```

**例 10: 精简不影响持久化存储**

```
场景: 文件读取 7 次,需要精简 2 次旧记录

【发送给 API 的上下文】
{
  "role": "tool",
  "content": "[该文件的历史读取内容已压缩,请参看最新读取结果]",
  "timestamp": 1738287900000
}

【会话持久化文件中的记录】
{
  "role": "tool",
  "content": "📄 src/components/Button.tsx (lines 100-150/250)\n100→export...",
  "timestamp": 1738287900000
}

关键说明:
- ✅ 发送给 API 时内容被精简
- ✅ 本地会话文件保存完整原始内容
- ✅ 恢复会话后再次发送给 API 时,依然会精简
```

### 3.3 识别 filesystem-read 工具返回内容

**识别方式 1: 通过 tool_call_id 关联**

```
1. 遍历所有 role === 'tool' 的消息
2. 通过 message.tool_call_id 在 conversationMessages 中查找对应的 tool_calls
3. 检查 tool_call.function.name 是否为 'filesystem-read'
```

**识别方式 2: 通过内容特征判断**(备用方案)

```
检查 content 是否包含文件读取结果的特征:
- 包含 "📄" 开头的文件头部
- 包含行号格式 "123→"
- 包含符号索引信息

但优先使用方式1,更准确
```

### 3.4 错误识别

**识别方式**:

```
满足以下任一条件即为错误返回:
- message.content 以 "Error:" 开头
- message.messageStatus === 'error'
```

**示例**:

```json
// ✅ 是错误返回(content 以 Error: 开头)
{
  "role": "tool",
  "content": "Error: ENOENT: no such file or directory, open 'src/missing.ts'"
}

// ✅ 是错误返回(messageStatus === 'error')
{
  "role": "tool",
  "content": "...",
  "messageStatus": "error"
}
```

---

## 4. 实现位置建议

**文件**: `source/hooks/conversation/utils/messageCleanup.ts`

**新增函数**: `simplifyHistoricalFileReads(messages: ChatMessage[]): void`

**调用位置**: `source/hooks/conversation/useConversation.ts`

```typescript
// 在 useConversation.ts 中的调用位置(行 345 附近)
const apiMessages = [...conversationMessages];
simplifyOutdatedTerminalResults(apiMessages); // 现有:精简命令行结果
simplifyHistoricalFileReads(apiMessages); // 新增:精简文件读取历史
```

---

## 5. 实现伪代码逻辑

```
函数 simplifyHistoricalFileReads(messages):
    定义 保留最近数量 = 5

    // ========================================
    // 步骤1: 构建工具调用ID到参数的映射
    // ========================================
    工具调用映射 = {}
    对于 每个 msg 在 messages 中:
        如果 msg.role === 'assistant' 且 msg.tool_calls 存在:
            对于 每个 tool_call 在 msg.tool_calls 中:
                工具调用映射[tool_call.id] = {
                    工具名: tool_call.function.name,
                    参数: JSON.解析(tool_call.function.arguments)
                }

    // ========================================
    // 步骤2: 收集所有 filesystem-read 工具返回,按文件分组
    // ========================================
    文件读取历史 = {}  // Map<文件路径, 数组[{索引, 时间戳, 是否错误}]>

    对于 每个 msg 在 messages 中(按索引顺序):
        如果 msg.role === 'tool' 且 msg.timestamp 存在:
            // 通过 tool_call_id 查找对应的工具调用
            工具调用 = 工具调用映射[msg.tool_call_id]

            如果 工具调用 存在 且 工具调用.工具名 === 'filesystem-read':
                // 提取文件路径
                文件路径列表 = 提取文件路径(工具调用.参数.filePath)

                对于 每个 文件路径 在 文件路径列表 中:
                    规范化路径 = 规范化路径(文件路径)

                    如果 规范化路径 为空:
                        继续  // 无法识别文件,跳过

                    // 初始化文件的历史记录
                    如果 文件读取历史[规范化路径] 不存在:
                        文件读取历史[规范化路径] = []

                    // 判断是否错误
                    是否错误 = 判断是否错误(msg)

                    // 添加到历史记录
                    文件读取历史[规范化路径].添加({
                        索引: msg.索引,
                        时间戳: msg.timestamp,
                        是否错误: 是否错误
                    })

    // ========================================
    // 步骤3: 对每个文件的读取记录按时间排序,标记需要精简的
    // ========================================
    需要精简的索引 = []

    对于 每个 (文件路径, 读取记录) 在 文件读取历史 中:
        // 按时间戳倒序排序(最新的在前)
        读取记录.排序((a, b) => b.时间戳 - a.时间戳)

        // 统计成功读取次数(错误不计入)
        成功读取计数 = 0
        成功读取索引 = []

        对于 每次 在 读取记录 中:
            如果 不 每次.是否错误:
                成功读取计数++
                成功读取索引.添加(每次.索引)

        // 如果成功读取次数超过 5 次,标记超出部分
        如果 成功读取计数 > 保留最近数量:
            超出部分索引 = 成功读取索引.切片(保留最近数量)  // 从第6个开始
            需要精简的索引.添加(...超出部分索引)

    // ========================================
    // 步骤4: 执行精简
    // ========================================
    对于 每个 索引 在 需要精简的索引 中:
        如果 messages[索引] 存在:
            messages[索引].content = "[该文件的历史读取内容已压缩,请参看最新读取结果]"

    // ========================================
    // 步骤5: 日志记录
    // ========================================
    如果 需要精简的索引.长度 > 0:
        输出日志: 精简了 X 个历史文件读取内容

函数 提取文件路径(filePath参数):
    // 支持单文件路径字符串
    如果 是字符串(filePath参数):
        返回 [filePath参数]

    // 支持文件路径数组
    如果 是数组(filePath参数):
        平展后的路径 = []
        对于 每个 项 在 filePath参数 中:
            如果 是字符串(项) 且 项 不为空:
                平展后的路径.添加(项)
        返回 平展后的路径

    // 支持对象数组格式 [{path: "file1.ts"}, {path: "file2.ts"}]
    如果 是数组(filePath参数) 且 filePath参数.长度 > 0:
        如果 filePath参数[0].path 存在:
            平展后的路径 = []
            对于 每个 项 在 filePath参数 中:
                如果 项.path 存在:
                    平展后的路径.添加(项.path)
            返回 平展后的路径

    返回 []

函数 规范化路径(文件路径):
    尝试:
        // 移除项目根目录前缀
        相对路径 = path.relative(项目根目录, 文件路径)

        // 如果无法转为相对路径,使用原路径
        如果 相对路径.startsWith('..'):
            相对路径 = 文件路径

        // 规范化路径
        规范化后 = path.normalize(相对路径)

        // 移除 "./" 前缀
        如果 规范化后.startsWith('./'):
            规范化后 = 规范化后.切片(2)

        返回 规范化后
    捕获:
        返回 ""  // 路径无效,返回空字符串

函数 判断是否错误(message):
    // 方法1:检查 content 前缀
    如果 message.content.以("Error:") 开头:
        返回 true

    // 方法2:检查 messageStatus
    如果 message.messageStatus === 'error':
        返回 true

    返回 false
```

---

## 6. 实现注意事项

### 6.1 性能优化

- 使用 Map 数据结构存储文件读取历史,提高查找效率
- 路径规范化结果缓存,避免重复计算
- 只遍历消息数组一次,构建工具调用映射

### 6.2 兼容性

- 处理老会话中缺少 tool_calls 的情况
- 处理不同的 filePath 参数格式(字符串、数组、对象数组)
- 处理相对路径和绝对路径

### 6.3 边界情况

- 空文件路径不精简
- 无法识别的文件路径不精简
- 目录读取与文件读取同等对待
- 错误读取不计入限制,始终保留

### 6.4 日志与调试

- 记录精简的文件路径和次数
- 记录无法提取路径的工具返回
- 使用 debug 模式输出详细信息

---

## 7. 验收标准

- [ ] 同一文件读取超过 5 次时,只保留最新 5 次,旧读取精简为占位符
- [ ] 文件读取未超过 5 次时,全部保留,不精简
- [ ] 错误读取不计入 5 次限制,始终保留完整错误信息
- [ ] 其他类型工具返回不受影响
- [ ] 存储的历史消息未被修改
- [ ] 路径规范化正确处理各种路径格式
- [ ] 批量读取多个文件时,每个文件独立计数
- [ ] 无法提取文件路径时,不精简该记录
- [ ] 添加了日志输出,便于调试和监控

---

## 8. 后续优化建议

- [ ] 考虑将保留数量(5 个)设为可配置参数
- [ ] 监控精简效果,统计上下文节省的 token 数量
- [ ] 根据实际使用情况调整保留数量
- [ ] 考虑文件大小权重,大文件的读取可以保留更少次数
      目的是避免同一个文件的重复读取内容占用过多的上下文,且旧的读取内容通常已经过时且重复.而且编辑工具返回不会被精简.且会提供编辑前后差异,会提供文件的历史信息. -->

已完成